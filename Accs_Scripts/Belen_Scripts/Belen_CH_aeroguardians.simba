{$IFNDEF SCRIPT_CHAIN}
  {$DEFINE SRL_USE_REMOTEINPUT}
  {$I SRL-T/osr.simba}
  {$I WaspLib/osr.simba}
{$ENDIF}
{$IFNDEF WL_GROUPING_INCLUDED}
  {$I WaspLib/optional/interfaces/gametabs/grouping.simba}
{$ENDIF}
{$include_once ../Scripts/Accs_Scripts/RemiLib.simba}

Const
{---------Start setup---------}
  NEAREND          = 90;    // % of Great Guardian power for end-game script logic to kick in
  FORCEBALANCE     = True;  // Forces the script to keep points balanced at the cost of speed
  EXPERIMENTALWALK = True;  // Experimental hybrid walking to blend mainscreen walking with minimap walking (false for MS walking)
  DEBUGMODE        = True;  // Enable debug mode?
  FASTMODE         = True;  // Optimized gameplay at the expense of certain failsafes
{----------End setup----------}


  UNKNOWN    = -1;
  TYPEAIR    = 0;
  TYPEWATER  = 1;
  TYPEEARTH  = 2;
  TYPEFIRE   = 3;
  TYPEMIND   = 4;
  TYPEBODY   = 5;
  TYPECOSMIC = 6;
  TYPECHAOS  = 7;
  TYPENATURE = 8;
  TYPELAW    = 9;
  TYPEDEATH  = 10;
  TYPEBLOOD  = 11;
  INACTIVE   = 12;

Type
  EState = (
    ENTER_GAME,WAITING,NEW_GAME,GATHER_FRAGMENTS,GATHER_ESSENCE,
    CRAFT_ESSENCE,CRAFT_RUNES,POWERUP,EXIT_ALTAR,CHANGE_WORLDS
  );

  TMSObject = record
    Name      : String;
    Colors    : Array of TCTS2Color;
    SecondCol,
    ExitCol   : TCTS2Color;
    UpText    : TStringArray;
    Expand    : Int32;
    Tile,
    WalkTile,
    MidTile   : TPoint;
    ExitTiles : TPointArray;
  end;

  TScript = record
    Version                            : String;
    State                              : EState;

    GuardianPowerBox, EEnergyBox,
    CEnergyBox, PBox, TimeBox          : TBox;    //TORWENT EDIT
    ECircle, CCircle, PCircle          : TCircle; //TORWENT EDIT

    PouchIterations,EssLimit,
    RCLvl,RIndex,StartXP,WinCount,
    LossCount,EPoints,CPoints,
    LossStreak,FragsToMine,TempIte     : Int32;

    FailReason                         : String;
    DropRunes,DropCells                : TStringArray;
    GameOver,IsRunning,CanMineEast,
    WalkSearch,IsObelisk,FoundObj,
    CanUsePouches,IsPortal,CastSpell,
    TakeBreaks,TakeSleeps,RepairShields,
    CraftC,CraftL,CraftD,CraftB,
    CatalyticOnly                      : Boolean;
    RSW                                : TRSWalker;
    OB_Altars                          : Array [TYPEAIR..TYPEBLOOD] of TMSObject;
    OB_Obelisks                        : Array [TYPEAIR..TYPEBLOOD] of TMSObject;
    OB_Workbench,OB_DepositPool,
    OB_RubbleW,OB_RubbleE,
    OB_Barrier,OB_Portal,OB_ExitPortal,
    OB_WestPortal,OB_HugeRemainsN,
    OB_HugeRemainsS,OB_LargeRemainsN,
    OB_LargeRemainsS,OB_Remains,
    OB_GreatGuardian,OB_ShieldN,
    OB_ShieldNW,OB_ShieldNE,
    OB_CellBench,WalkObj               : TMSObject;

    NPC_Cordelia                       : TRSMMDot;

    MsgCooldown,DropTimer              : TCountDown;
    TrueRunTime                        : TStopwatch;

    ShutdownTime                       : Int64;
  end;

Const
  TempleBounds      : TPointArray  = [[265,218], [246,219], [225,211], [203,194], [195,169],
                                      [194,138], [195,108], [199,83], [225,66], [258,63],
                                      [317,63], [345,72], [357,91], [359,112], [360,142],
                                      [365,156], [363,181], [357,194], [340,203], [325,205],
                                      [315,210], [304,217], [279,218]];

  WestBounds        : TBox         = [161,96,196,175];
  EastBounds        : TBox         = [363,90,392,163];
  Lobby             : TBox         = [265,219,294,266];
  RuneNames         : TStringArray = ['air','water','earth','fire','mind','body','cosmic',
                                      'chaos','nature','law','death','blood'];
  GameWorlds        : TIntegerArray = [492];
  //445,441,478,490,492 gotr worlds
Var
  Bot: TScript;

procedure TScript.WriteMsg(Message: String);
begin
  WriteLn('[Bot]: '+Message);
end;

{ Import SRL-F routines }
// Combination of miss mouse + slowing near the target destination
{procedure TMouse.HumanMove(Point: TPoint);
var
  mPt: TPoint;
  S: Int32;
  Miss: Double;
  Range: Int64;
begin
  S := Self.Speed;
  Range := Trunc(Power(Self.Position().DistanceTo(Point), 0.80)); // how much possible range to miss
  Miss := SRL.SkewedRand(0.9, 0.1, 1.5); // Where miss will happen. 1 = destination (P).

  mPt.X := Trunc((1-Miss)*Self.Position().X + Miss*Point.X);
  mPt.Y := Trunc((1-Miss)*Self.Position().Y + Miss*Point.Y);

  mPt.X += SRL.NormalRange(-Range, Range);
  mPt.Y += SRL.NormalRange(-Range, Range);

  Self.Move(mPt);
  Self.Speed := round(S*0.85);
  Self.Move(Point);
  Self.Speed := S;
end;
}



{--------------------------------------------------------------------------------}
{                                    SHIFT DROP                                  }
{--------------------------------------------------------------------------------}


function TRSInventory.QuickShiftDrop(Items: TRSItemArray; Pattern: TIntegerArray=DROP_PATTERN_REGULAR): Boolean;
var
  I: Int32;
  Circle: TCircle;
  Boxes: TBoxArray;
  Slots,Order: TIntegerArray;
begin
  if (Length(Items) = 0) then
    Exit;

  if Self.FindItems(Items, Slots) then
  begin
    Result := True;
    for I := 0 to High(Pattern) do
      if Pattern[I] in Slots then
        Order += Pattern[I];
  end;

  IsKeyDown(VK_SHIFT); // Clear cache
  KeyUp(VK_SHIFT);

  Boxes := Self.GetSlotBoxes;

  try
    if not IsKeyDown(VK_SHIFT) then
    begin
      KeyDown(VK_SHIFT);
      Wait(50,100,wdLeft); // Fix provided by Slacky <3
    end;
    for i:=0 to high(Order) do
    begin
      if Self.IsSlotUsed(Order[I]) then
      begin
        Mouse.Move(Self.GetSlotBox(Order[I]));
        Mouse.Click(MOUSE_LEFT);

        // Spam click a little
        for 1 to SRL.TruncatedGauss(0, 3) do
        begin
          Circle.X := Mouse.Position().X;
          Circle.Y := Mouse.Position().Y;
          Circle.Radius := 5;

          Mouse.Click(Circle, MOUSE_LEFT, True);
        end;

        WaitEx(35,5);
      end;
    end;
  finally
    if IsKeyDown(VK_SHIFT) then
      KeyUp(VK_SHIFT);
  end;

  KeyUp(VK_SHIFT);
end;

{function TIntegerArray.GetRarest(): Int32;
var
  i,hits,least: Int32;
begin
  Self.Sort();
  for i:=0 to high(Self) do
  begin
    hits := Length(Self.FindAll(Self[i]));
    if i<1 then
      least := Self[i]
    else if i>0 then
      if hits < Length(Self.FindAll(Self[i-1])) then
        least := Self[i];
  end;

  Result := least;
end;
}
{function TRSMinimap.PercentBlack(): Integer;
var TPA: TPointArray;
begin
  SRL.FindColors(TPA, CTS1(0,0), Self.Bounds());
  if Length(TPA) < 1 then Exit;
  FilterPointsPie(TPA, 0, 360, 0, 73, Self.Center.X, Self.Center.Y);
  Result := ceil((Length(TPA) * 100) / ((Pi * (73 * 73)) * ((360 - 0) / 360.0)-((Pi * 0) * 1)));
end;
}

// Undo the bogged down version in WaspLib
function TRSChooseOption.Select(Text: TStringArray; MouseAction: Int32 = MOUSE_LEFT; CaseSensitive: Boolean = True; CloseIfNotFound: Boolean = True): Boolean; override;
var
  Choices: TRSChooseOption_OptionArray;
  I, J: Int32;
begin
  if Self.Open() then
  begin
    Wait(0, 750, wdLeft);

    Choices := GetOptions();

    for I := 0 to High(Choices) do
      for J := 0 to High(Text) do
        if (CaseSensitive and (Text[J] in Choices[I].Text)) or ((not CaseSensitive) and (Lowercase(Text[J]) in Lowercase(Choices[I].Text))) then
        begin
          Self.Select(Choices[I], MouseAction);
          Exit(True);
        end;

    if CloseIfNotFound then
    begin
      WaitEx(400, 150);

      Self.Close();
    end;
  end;
end;

// by Rasta Magician, veteran SRL-er

{
function ProgReport(
                           ResultType:int32; ScriptName, ScriptAuthor, ScriptVersion: String;
                           VarNames: TStringArray;
                           VarValues: TVariantArray
                          ): Variant;
var
  TSA        : TStringArray;
  s,s2       : String;
  s3         : String := '=';
  s4         : String := ' ';
  i, i2, L   : Int32;
begin
  if (ResultType = 2) then
    Result := '';

  if length(VarNames) <> Length(VarValues) then
  begin
    Writeln('VarNames and VarValues must be the same length');
    exit;
  end;
  SetLength(TSA, 3 + Length(VarNames) + 4);
  s2 := 'by '+ScriptAuthor;

  TSA[0] := s3;
  TSA[1] := ScriptName.Capitalize+' '+ScriptVersion;
  TSA[2] := s2;
  TSA[3] := s3;

  i2 := 3 + Length(VarNames);

  for i:= 4 to i2 do
    L := Max(L, Length(VarNames[i-4]));

  for i:= 4 to i2 do
  begin
    s := VarValues[i-4];
    TSA[i] := Padr((VarNames[i-4]).Capitalize, L)+' : '+ s.Capitalize;
  end;

  TSA[i2+1] := s3;
  TSA[i2+2] := ScriptName.Capitalize+' '+ScriptVersion;
  TSA[i2+3] := s3;

  i2 := 0;
  for i:= 0 to High(TSA) do
    i2 := Max(i2, Length(TSA[i]));

  TSA[0]           := s3.Replicate(i2);
  TSA[3]           := s3.Replicate(i2);
  TSA[High(TSA)-2] := s3.Replicate(i2);
  TSA[High(TSA)]   := s3.Replicate(i2);

  TSA[2] := s4.Replicate(round((i2 - Length(TSA[2]))/2)) + TSA[2]; //centering by ScriptAuthor
  TSA[High(TSA)-1] := s4.Replicate(round((i2 - Length(TSA[High(TSA)-1]))/2)) + TSA[High(TSA)-1];

  for i:= 0 to High(TSA) do
    if (TSA[i][1] = s3) then
      case ResultType of
        0 : writeln     ('[='+Padr(TSA[i], i2)+'=]');
        1 : writeln     ('[='+Padr(TSA[i], i2)+'=]');
        2 : Result := Result + '[='+Padr(TSA[i], i2)+'=]' + chr(13);
        else begin Writeln('Invalid Result Type'); exit; end;
      end
    else
      case ResultType of
        0 : writeln     ('[ '+Padr(TSA[i], i2)+' ]');
        1 : writeln     ('[ '+Padr(TSA[i], i2)+' ]');
        2 : Result := Result + '[ '+Padr(TSA[i], i2)+' ]' + chr(13);
        else begin Writeln('Invalid Result Type'); exit; end;
      end;

  if not ResultType = 2 then Result := true;
end;
}

// By Nava2
{function TPABetweenPoints(P1, P2: TPoint; Interval, Rand: Integer): TPointArray;
var
  hyp, xR, yR: Extended;
  l: Integer;
begin
  SetLength(Result, Ceil(Distance(P1.X, P1.y, P2.X, P2.Y) * 1.0 / Interval) + 1);
  Result[0] := P1;

  if (Distance(P1.X, P1.Y, P2.X, P2.Y) <= Interval) then
  begin
    Result[High(Result)] := P2;
    Exit;
  end;

  hyp := Hypot(P1.X - P2.x, P1.Y - P2.Y);
  xR := (P2.X - P1.X) / hyp;
  yR := (P2.Y - P1.Y) / hyp;

  for l := High(Result) - 1 downto 1 do
  begin
    Result[l].X := Round(P1.X + l * Interval * xR) + RandomRange(-Rand, Rand);
    Result[l].Y := Round(P1.Y + l * Interval * yR) + RandomRange(-Rand, Rand);
  end;

  Result[High(Result)] := P2;
end;

procedure TAntiBan.HoverMSTile(DotType: ERSMinimapDot; RightClick: Boolean = False);
var
  Tries: Int32;
  a: Double;
  rDot: TPoint;
  MSBox: TBox;
  Dots,cTPA: TPointArray;
  cArr: TIntegerArray;
begin
  Dots := Minimap.GetDots(DotType);
  if Dots.Len() < 1 then Exit;
  a := Minimap.GetCompassAngle(False);
  repeat
    Inc(Tries);
    rDot := Dots[Random(Low(Dots),High(Dots))];
    MSBox := Minimap.VecToMsRect(Vec3(rDot.X + 2, rDot.Y + 2, 0), 1, 1, a).Bounds;
    if MainScreen.Bounds.Contains(MSBox) then
    begin
      Self.DebugLn('Hovering random ' + toStr(DotType));
      cArr := GetColors(TPAFromBox(MSBox));
      SRL.FindColors(cTPA, CTS1(cArr.GetRarest(), 30), MSBox);
      Mouse.HumanMove(cTPA.Mean());
      if RightClick then
        Mouse.Click(MOUSE_RIGHT);

      wait(1500, 2700);
      if RightClick then
        ChooseOption.Close();
      Exit;
    end;
  until(Tries > 10);
end;
}{
procedure TAntiban.HoverMSNPCs();
begin
  Self.HoverMSTile(ERSMinimapDot.NPC);
end;

procedure TAntiban.HoverMSPlayers();
begin
  Self.HoverMSTile(ERSMinimapDot.PLAYER);
end;

procedure TMouse.RandomMovement();
var
  S: Int32 := Self.Speed;
begin
  Self.Speed := SRL.NormalRange(5,9);
  Self.Move(Box(Mouse.Position, 75, 75), True, );
  Self.Speed := S;
end;
  }
{ End SRL-F import }

{-----------------------------------------------------------------------------}




                              //WALKER OVERRIDE!




{-----------------------------------------------------------------------------}
function TRSWalker.IsWalkable(WorldPoint: TPoint; PlayerPoint: TPoint; Angle: Double): Boolean; override;
var
  MinimapPoint: TPoint;
  B: TBox;
begin
  if Inventory.GetSelectedSlot >= 0 then
    ChooseOption.Select('Cancel');

  MinimapPoint := Self.WorldToMM(PlayerPoint, WorldPoint, Angle);

  case Self.ScreenWalk of
    True:
      begin
        B := Minimap.PointToMSRect(MinimapPoint, Angle).Bounds;
        Result := MainScreen.IsVisible(B.Middle);
      end;

    False: Result := Minimap.IsPointOn(MinimapPoint, -1);
  end;

end;

procedure TScript.Report();
var
  XpGained: Int32;
  RunTime: Int64;
  SArr: TStringArray;
  VArr: TVariantArray;
begin
  XPBar.EarnedXP(); //TORWENT_EDIT: Since you are using wasplib, this is all that's required to update StatsPaypload XP.
  //You could optionally refactor somethings to not have duplicate stuff doing the same thing.
  //E.G.: Self.StartXP = WL.XP.Start
  if not APIClient.IsSetup or APIClient.Timer.IsFinished() then
    APIClient.SubmitStats(APIClient.GetUUID());

  XpGained := XPBar.Read()-Self.StartXP;
  RunTime  := Self.TrueRunTime.ElapsedTime();

  if (not DEBUGMODE) then
    ClearDebug();

  SArr := ['Runtime','XP gained','Wins/Losses','Elemental points','Catalytic points'];
  VArr := [SRL.MsToTime(GetTimeRunning, Time_Short),
           ToStr(Round(XpGained, 2), '(', Round(XpGained / (RunTime / 1000 / 60 / 60)), ' / hr)'),
           ToStr(Self.WinCount, ' / ', Self.LossCount),
           ToStr(Self.EPoints, '(', Round(Self.EPoints / (RunTime / 1000 / 60 / 60)), ' / hr)'),
           ToStr(Self.CPoints, '(', Round(Self.CPoints / (RunTime / 1000 / 60 / 60)), ' / hr)')];

  if Self.TakeBreaks then
  begin
    SArr += 'Until break';
    VArr += Antiban.TimeUntilBreak(Antiban.Breaks[0]);
  end;

  if Self.TakeSleeps then
  begin
    SArr += 'Until sleep';
    VArr += SRL.MsToTime(Max(0, Round(Antiban.Sleeps[0].NextAtTime - GetTimeRunning)), TIME_BARE);
  end;

  SArr += 'Shutdown';
  VArr += ToStr(SRL.MsToTime(Self.ShutdownTime - GetTimeRunning, Time_Short));

  ProgReport(1, 'AeroGuardians','Flight', Self.Version, SArr, VArr);
end;

{
procedure TAntiban.SmallCameraRotation();
begin
  Self.DebugLn('Small camera rotation');
  Minimap.SetCompassAngle(Minimap.GetCompassAngle+(Random(-15,15)));
end;
   }

{-----------------------------------------------------------------------------}




                              //GLOBAL PROCEDURES!




{-----------------------------------------------------------------------------}
{$IFNDEF SCRIPT_CHAIN}
procedure BreakPause(Task: PBreakTask);
Var T: PBreakTask;
begin
  Bot.TrueRunTime.Pause;
  T := Task;
end;

procedure BreakResume(Task: PBreakTask);
Var T: PBreakTask;
begin
  if GetTimeRunning() > Bot.ShutdownTime then
    Exit;

  Bot.TrueRunTime.Resume;
  T := Task;
end;
{$ENDIF}
procedure SleepPause(Task: PSleepTask);
Var T: PSleepTask;
begin
  Bot.TrueRunTime.Pause;
  T := Task;
end;

procedure SleepResume(Task: PSleepTask);
Var T: PSleepTask;
begin
  if GetTimeRunning() > Bot.ShutdownTime then
    Exit;

  Bot.TrueRunTime.Resume;
  T := Task;
end;
           {
procedure TAntiban.DoLoseFocus();
Var T: Int32;
begin
  T := SRL.NormalRange(800,3500);
  Self.DebugLn('Losing focus for '+SRL.MsToTime(T, Time_Short));
  Self.LoseFocus(T);
end;  }
{
procedure TScript.SetupAntiban();
begin
  Antiban.Skills += ERSSKILL.RUNECRAFTING;
  Antiban.Skills += ERSSKILL.MINING;
  Antiban.Skills += ERSSKILL.CRAFTING;

  Antiban.AddTask(ONE_MINUTE*2,   @Mouse.RandomMovement);
  Antiban.AddTask(ONE_MINUTE*4,   @Antiban.SmallCameraRotation);
  Antiban.AddTask(ONE_MINUTE*6,   @Antiban.HoverMSPlayers);
  Antiban.AddTask(ONE_MINUTE*7,   @Antiban.DoLoseFocus);
  Antiban.AddTask(ONE_MINUTE*7,   @Antiban.RandomRotate);
  Antiban.AddTask(ONE_MINUTE*8,   @Antiban.HoverMSNPCs);
  Antiban.AddTask(ONE_MINUTE*25,  @Antiban.HoverSkills);
  if Self.TakeBreaks then
  begin
    Antiban.OnStartBreak  := @BreakPause;
    Antiban.OnFinishBreak := @BreakResume;
  end;

  if Self.TakeSleeps then
  begin
    Antiban.OnStartSleep  := @SleepPause;
    Antiban.OnFinishSleep := @SleepResume;
  end;
end;
}
procedure TScript.SetupAntiban();
begin
  Antiban.Skills += ERSSKILL.RUNECRAFTING;
  Antiban.Skills += ERSSKILL.MINING;
  Antiban.Skills += ERSSKILL.CRAFTING;

  Antiban.AddTask(ONE_MINUTE*2,   @Mouse.RandomMovement);
  Antiban.AddTask(ONE_MINUTE*4,   @Antiban.SmallCameraRotation);
  Antiban.AddTask(ONE_MINUTE*6,   @Antiban.HoverMSPlayers);
  Antiban.AddTask(ONE_MINUTE*7,   @Antiban.DoMidLoseFocus);
  Antiban.AddTask(ONE_MINUTE*7,   @Antiban.RandomRotate);
  Antiban.AddTask(ONE_MINUTE*8,   @Antiban.HoverMSNPCs);
  Antiban.AddTask(ONE_MINUTE*25,  @Antiban.HoverSkills);

  if Self.TakeBreaks then
  begin
    Antiban.OnStartBreak  := @BreakPause;
    Antiban.OnFinishBreak := @BreakResume;
  end;

  if Self.TakeSleeps then
  begin
    Antiban.OnStartSleep  := @SleepPause;
    Antiban.OnFinishSleep := @SleepResume;
  end;
end;

function TScript.FindHopperMsg(): Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  Result := ('finish' in Chat.GetMessage(CHAT_INPUT_LINE - 1, [CHAT_COLOR_BLACK])) or
            ('finish' in Chat.GetMessage(CHAT_INPUT_LINE - 2, [CHAT_COLOR_BLACK]));
end;

function TScript.IsInTemple(): Boolean;
begin
  Result := SRL.PointInPoly(Self.RSW.GetMyPos(), TempleBounds);
end;

function TScript.IsInWestArea(): Boolean;
begin
  Result := WestBounds.Contains(Self.RSW.GetMyPos());
end;

function TScript.IsInEastArea(): Boolean;
begin
  Result := EastBounds.Contains(Self.RSW.GetMyPos());
end;

function TScript.IsInLobby(): Boolean;
begin
  Result := Lobby.Contains(Self.RSW.GetMyPos());
end;

function TScript.GetCosmicCenter(): TPoint;
var
  WallCol: TCTS0Color  := CTS0(15986161, 20);
  FloorCol: TCTS0Color := CTS0(6710892, 20);
  TPA: TPointArray;
begin
  if SRL.FindColors(TPA, WallCol, Minimap.Bounds) > 0 then
  begin
    TPA := TPA.FilterDist(40, Minimap.Bounds.Width/2, Minimap.Center.X, Minimap.Center.Y);
    if TPA.Len > 0 then
      Exit(TPA.Mean);
  end;

  if SRL.FindColors(TPA, FloorCol, Minimap.Bounds) > 0 then
  begin
    TPA := TPA.FilterDist(40, Minimap.Bounds.Width/2, Minimap.Center.X, Minimap.Center.Y);
    if TPA.Len > 0 then
      Exit(TPA.Mean);
  end;
end;

function TScript.GetCosmicWalkway(): TPoint;
var
  WalkCol: TCTS2Color := CTS2(11053224, 11, 1.58, 0.05);
  TPA,DelTPA,ResTPA: TPointArray;
begin
  if SRL.FindColors(TPA, WalkCol, Mainscreen.Bounds) > 0 then
  begin
    DelTPA := TPA;
    FilterPointsBox(DelTPA, 1, 1, Self.PBox.X2, Self.PBox.Y2);
    ResTPA := ClearTPAFromTPA(TPA, DelTPA);
    if Length(ResTPA) < 1 then Exit;
    SortTPAFrom(ResTPA, Mainscreen.Center);
    Exit(ResTPA[High(ResTPA)]);
  end;
end;

function TScript.IsPortalActive(): Boolean;
var
  Col: TCTS2Color := CTS2(3785983, 17, 0.06, 0.01);
  SArr: TStringArray := ['SW -','SE -','S -','E -'];
  Tiles: TPointArray := [[229,176],[324,177],[278,199],[325,137]];
  TPA: TPointArray;
  Loc: String;
  i: Int32;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if SRL.FindColors(TPA, Col, Self.PCircle.Bounds) > 0 then // TORWENT EDIT: now uses Self.PCircle as the circle.
  begin
    TPA    := TPA.FilterDist(0, Self.PCircle.Radius, Self.PCircle.X, Self.PCircle.Y);
    Result := TPA.Len = 267;
  end;

  if Result then
  begin
    Loc := OCR.Recognize(Self.PBox, TOCRColorFilter.Create([16777215, 5]), RS_FONT_PLAIN_12);
    for i:=0 to 3 do
      if (Pos(SArr[i], Loc) <> 0) then
      begin
        Self.OB_Portal.Tile := Tiles[i];
        break;
      end;

    Self.OB_Portal.WalkTile := Self.OB_Portal.Tile;
  end;
end;

// TORWENT EDIT: old function TScript.GetUIBounds()
procedure TScript.SetUIBounds();
begin
  case RSClient.Mode of
    ERSClientMode.FIXED:
      begin
        Self.GuardianPowerBox := [13,33,172,49];
        Self.ECircle          := [51,79,15];
        Self.CCircle          := [132,79,15];
        Self.PCircle          := [213,109,15];
        Self.EEnergyBox       := [49,119,89,134];
        Self.CEnergyBox       := [134,119,169,134];
        Self.PBox             := [187,132,241,144];
        Self.TimeBox          := [80,75,105,90];
      end;

    ERSClientMode.RESIZABLE_CLASSIC,
    ERSClientMode.RESIZABLE_MODERN:
      begin
        Self.GuardianPowerBox := [9,29,168,45];
        Self.ECircle          := [47,75,15];
        Self.CCircle          := [128,75,15];
        Self.PCircle          := [209,105,15];
        Self.EEnergyBox       := [45,115,85,130];
        Self.CEnergyBox       := [135,115,165,130];
        Self.PBox             := [183,128,237,140];
        Self.TimeBox          := [70,70,105,85];
      end;
  end;
end;

function TScript.GetPower(): Int32;
begin
  Result := -1;
  Result := OCR.RecognizeNumber(Self.GuardianPowerBox, TOCRColorFilter.Create([0]), RS_FONT_PLAIN_11);
end;

function TScript.GetRemainingTime(): Int32;
begin
  Result := 0;
  Result := OCR.RecognizeNumber(Self.TimeBox, TOCRColorFilter.Create([16777215]), RS_FONT_PLAIN_12);
end;

// TORWENT EDIT: now uses Self.ECircle as the circle.
function TScript.GetETypeRune(): Int32;
var
  i: Int32;
  Cols: TIntegerArray = [16777215,15226142,3826845,1904361];
  Counts: TIntegerArray = [142,146,136,189];
  TPA: TPointArray;
begin
  Result := INACTIVE;
  for i:=Low(Cols) to High(Cols) do
    if SRL.FindColors(TPA, CTS1(Cols[i], 10), Self.ECircle.Bounds) > 0 then
    begin
      TPA := TPA.FilterDist(0, Self.ECircle.Radius, Self.ECircle.X, Self.ECircle.Y);
      if TPA.Len = Counts[i] then
        Exit(i);
    end;
end;

// TORWENT EDIT: Now uses Self.CCircle as the circle.
function TScript.GetCTypeRune(): Int32;
var
  i: Int32;
  Cols: TIntegerArray = [1341146,15226142,65535,1341146,2608702,15226142,16777215,3352254];
  Counts: TIntegerArray = [82,82,116,144,150,172,186,146];
  TPA: TPointArray;
begin
  Result := INACTIVE;
  for i:=Low(Cols) to High(Cols) do
    if SRL.FindColors(TPA, CTS1(Cols[i], 10), Self.CCircle.Bounds) > 0 then
    begin
      TPA := TPA.FilterDist(0, Self.CCircle.Radius, Self.CCircle.X, Self.CCircle.Y);
      if TPA.Len = Counts[i] then
       Exit(i+4);
    end;
end;

function TScript.GetEEnergy(): Int32;
begin
  Result := 0;
  Result := OCR.RecognizeNumber(Self.EEnergyBox, TOCRColorFilter.Create([16777215]), RS_FONT_PLAIN_12);
end;

function TScript.GetCEnergy(): Int32;
begin
  Result := 0;
  Result := OCR.RecognizeNumber(Self.CEnergyBox, TOCRColorFilter.Create([16777215]), RS_FONT_PLAIN_12);
end;

function TScript.GetEnergyDiff(): Int32;
begin
  Result := Max(0, Self.GetEEnergy - Self.GetCEnergy);
end;

function TScript.GetAltarLoc(): Int32;
var
  MyPos: TPoint := Self.RSW.GetMyPos();
begin
  Result := UNKNOWN;

  if MyPos.InBox([1362,614,1439,692]) then Exit(TYPEAIR);
  if MyPos.InBox([838,605,960,700])   then Exit(TYPEWATER);
  if MyPos.InBox([524,535,768,736])   then Exit(TYPEEARTH);
  if MyPos.InBox([296,566,418,695])   then Exit(TYPEFIRE);

  if MyPos.InBox([1061,565,1236,717]) then Exit(TYPEMIND);
  if MyPos.InBox([37,564,174,694])    then Exit(TYPEBODY);
  if MyPos.InBox([564,29,765,235])    then Exit(TYPECOSMIC);
  if MyPos.InBox([1084,23,1273,171])  then Exit(TYPECHAOS);
  if MyPos.InBox([864,294,973,403])   then Exit(TYPENATURE);
  if MyPos.InBox([1093,301,1274,483]) then Exit(TYPELAW);
  if MyPos.InBox([820,22,1027,203])   then Exit(TYPEDEATH);
  if MyPos.InBox([1378,104,1496,276]) then Exit(TYPEBLOOD);

  if Minimap.PercentBlack > 50 then Exit(TYPECOSMIC);
end;

function TScript.CheckMessages(): Boolean;
var
  i: Int32;
  Msg,Nums,S1,S2: String;
begin
  if InRange(Chat.GetScrollPosition, 1, 99) then
    Chat.SetScrollPosition(100);

  if Self.GameOver then Exit;
  if Self.MsgCooldown.TimeRemaining > 0 then Exit;

  for i := 0 to CHAT_INPUT_LINE - 1 do
    if 'energy attuned' in Chat.GetMessage(i, [CHAT_COLOR_BLACK]) then
    begin
      Msg  := Chat.GetMessage(i, [CHAT_COLOR_BLACK,2101487]);
      Nums := ExtractFromStr(Msg, Numbers);
      if Nums.Len > 0 then
      begin
        S1 := Nums[1];
        S2 := Nums[2];
        Inc(Self.EPoints, StrToInt(S1));
        Inc(Self.CPoints, StrToInt(S2));
        Inc(Self.WinCount);
        Self.LossStreak := 0;
        Self.GameOver := True;
        Self.MsgCooldown.Init(120000);
        Exit(True);
      end;
    end;

  if Chat.FindMessage('defeated', [2101487]) then
    if Self.MsgCooldown.TimeRemaining <= 0 then
    begin
      Self.MsgCooldown.Init(120000);
      Inc(Self.LossCount);
      Inc(Self.LossStreak);
      Self.GameOver := True;
      Exit(True);
    end;
end;

function TScript.IsGameOver(WaitTime:Int32=0): Boolean;
var
  T: TCountdown;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  Result := (Self.GetPower() = 0) or (Self.GetPower() = 100);
  if (not Result) then
  begin
    if WaitTime < 1 then Exit((Self.GetETypeRune = INACTIVE) and (Self.GetCTypeRune = INACTIVE));
    if (Self.GetETypeRune = INACTIVE) and (Self.GetCTypeRune = INACTIVE) then
    begin
      T.Init(WaitTime);
      while T.TimeRemaining > 0 do
      begin
        if (not(Self.GetETypeRune = INACTIVE)) or (not(Self.GetCTypeRune = INACTIVE)) then
          Exit(False);
        WaitEx(115, 15);
      end;
    end;

    Result := (Self.GetETypeRune = INACTIVE) and (Self.GetCTypeRune = INACTIVE);
  end;
end;

function TScript.HasDegradedPouch(): Boolean;
var
  Pouches: TRSItemArray = [5511,5513,5515,26786];
begin
  Result := Inventory.ContainsAny(Pouches);
end;

function TScript.HasGuardStones(): Boolean;
var
  Stones: TRSItemArray = ['Elemental guardian stone','Catalytic guardian stone','Polyelemental guardian stone'];
begin
  Result := Inventory.ContainsAny(Stones);
end;

function TScript.HasChargedCell(): Boolean;
var
  Cells: TRSItemArray = ['Weak cell','Medium cell','Strong cell','Overcharged cell'];
begin
  Result := Inventory.ContainsAny(Cells);
end;

function TScript.HasRunes(): Boolean;
var
  i: Int32;
begin
  for i:=TYPEAIR to TYPEBLOOD do
    if Inventory.ContainsItem(RuneNames[i]+' rune') then
      Exit(True);
end;

function TScript.CanCraftRunes(RuneType: Int32): Boolean;
begin
  case RuneType of
    TYPEAIR..TYPEBODY: Result := True;
    TYPECOSMIC       : Result := Self.CraftC;
    TYPECHAOS        : Result := Self.RCLvl >= 35;
    TYPENATURE       : Result := Self.RCLvl >= 44;
    TYPELAW          : Result := (Self.RCLvl >= 54) and (Self.CraftL);
    TYPEDEATH        : Result := (Self.RCLvl >= 65) and (Self.CraftD);
    TYPEBLOOD        : Result := (Self.RCLvl >= 77) and (Self.CraftB);
  end;
end;

procedure TScript.DropStuff();
var
  i: Int32;
  DropRunes,DropCells: TRSItemArray;
  Talismans: TRSItemArray = ['Portal talisman (air)','Portal talisman (water)','Portal talisman (earth)','Portal talisman (fire)',
                             'Portal talisman (mind)','Portal talisman (body)','Portal talisman (cosmic)','Portal talisman (chaos)',
                             'Portal talisman (nature)','Portal talisman (law)','Portal talisman (death)','Portal talisman (blood)'];
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if Self.DropTimer.TimeRemaining > 0 then Exit;

  if Length(Self.DropRunes) > 0 then
  begin
    for i:=0 to High(Self.DropRunes) do
      if AnsiCompareStr(Self.DropRunes[i], '') > 0 then
        DropRunes += Self.DropRunes[i];
  end;

  if Length(Self.DropCells) > 0 then
  begin
    for i:=0 to High(Self.DropCells) do
      if AnsiCompareStr(Self.DropCells[i], '') > 0 then
        DropCells += Self.DropCells[i];
  end;

  if SRL.Dice(65) then
  begin
    if FASTMODE then
    begin
      Inventory.QuickShiftDrop(DropRunes);
      if Inventory.QuickShiftDrop(DropCells) then
      begin
        WaitEx(650, 40);
        WaitUntil(not Inventory.ContainsAny(DropCells), 125, 3500);
      end;
      Inventory.QuickShiftDrop(Talismans);
    end else
    begin
      if Length(DropRunes) > 0 then
        for i:=0 to High(DropRunes) do
          Inventory.ClickItem(DropRunes[i], 'Drop');
      if Length(DropCells) > 0 then
      begin
        for i:=0 to High(DropCells) do
          Inventory.ClickItem(DropCells[i], 'Drop');

        WaitEx(650, 40);
        WaitUntil(not Inventory.ContainsAny(DropCells), 125, 3500);
      end;
      for i:=0 to High(Talismans) do
        Inventory.ClickItem(Talismans[i], 'Drop');
    end;
  end else
  begin
    if FASTMODE then
    begin
      Inventory.QuickShiftDrop(Talismans);
      if Inventory.QuickShiftDrop(DropCells) then
      begin
        WaitEx(650, 40);
        WaitUntil(not Inventory.ContainsAny(DropCells), 125, 3500);
      end;
      Inventory.QuickShiftDrop(DropRunes);
    end else
    begin
      for i:=0 to High(Talismans) do
        Inventory.ClickItem(Talismans[i], 'Drop');
      if Length(DropCells) > 0 then
      begin
        for i:=0 to High(DropCells) do
          Inventory.ClickItem(DropCells[i], 'Drop');

        WaitEx(650, 40);
        WaitUntil(not Inventory.ContainsAny(DropCells), 125, 3500);
      end;
      if Length(DropRunes) > 0 then
        for i:=0 to High(DropRunes) do
          Inventory.ClickItem(DropRunes[i], 'Drop');
    end;
  end;

  Self.DropTimer.Init(10000);
end;

function TScript.HandlePouches(GiantOnly: Boolean=False; Fill: Boolean=True): Boolean;
var
  i: Int32;
  Pouches: TRSItemArray = ['Small pouch','Medium pouch',5511,'Large pouch',
                           5513];
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if (not Self.CanUsePouches) then
  begin
    Self.TempIte := 1;
    Exit;
  end else
    Self.TempIte := Self.PouchIterations;

  if SRL.Dice(25) then
    Pouches := [5513,'Large pouch',5511,'Medium pouch','Small pouch'];

  if Inventory.ContainsItem('Colossal pouch') then
    Pouches := ['Colossal pouch',26786]
  else if GiantOnly then
    Pouches := ['Giant pouch',5515];

  if (not Fill) then
    Result := Inventory.QuickShiftDrop(Pouches)
  else
    for i:= 0 to High(Pouches) do
    begin
      Result := Inventory.ClickItem(Pouches[i]);
      Wait(115, 175);
    end;
end;

function TMSObject.IsReachable(): Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  case Self.Tile of
  { Temple objects }
    Bot.OB_Obelisks[TYPEAIR].Tile,Bot.OB_Obelisks[TYPEWATER].Tile,Bot.OB_Obelisks[TYPEEARTH].Tile,
    Bot.OB_Obelisks[TYPEFIRE].Tile,Bot.OB_Obelisks[TYPEMIND].Tile,Bot.OB_Obelisks[TYPEBODY].Tile,
    Bot.OB_Obelisks[TYPECOSMIC].Tile,Bot.OB_Obelisks[TYPECHAOS].Tile,Bot.OB_Obelisks[TYPENATURE].Tile,
    Bot.OB_Obelisks[TYPELAW].Tile,Bot.OB_Obelisks[TYPEDEATH].Tile,Bot.OB_Obelisks[TYPEBLOOD].Tile,
    Bot.OB_RubbleW.Tile,Bot.OB_Workbench.Tile,Bot.OB_DepositPool.Tile,Bot.OB_Portal.Tile,Bot.OB_Remains.Tile,
    Bot.OB_GreatGuardian.Tile,Bot.OB_CellBench.Tile,Bot.OB_ShieldN.Tile,Bot.OB_ShieldNW.Tile,
    Bot.OB_ShieldNE.Tile:
    begin
      if Bot.IsInTemple then
        Exit(True)
      else
        Exit(False);
    end;
  { East mining area objects }
    Bot.OB_RubbleE.Tile,Bot.OB_LargeRemainsN.Tile,Bot.OB_LargeRemainsS.Tile:
      if Bot.IsInEastArea then
        Exit(True)
      else
        Exit(False);
  { West mining area objects }
    Bot.OB_HugeRemainsN.Tile,Bot.OB_HugeRemainsS.Tile,Bot.OB_WestPortal.Tile:
      if Bot.IsInWestArea then
        Exit(True)
      else
        Exit(False);
  { Misc. objects }
    Bot.OB_Barrier.Tile:
      if Bot.IsInTemple or Bot.IsInLobby then
        Exit(True)
      else
        Exit(False);
  { Altars / exit portals }
    Bot.OB_Altars[TYPEAIR].Tile,Bot.OB_Altars[TYPEWATER].Tile,Bot.OB_Altars[TYPEEARTH].Tile,
    Bot.OB_Altars[TYPEFIRE].Tile,Bot.OB_Altars[TYPEMIND].Tile,Bot.OB_Altars[TYPEBODY].Tile,
    Bot.OB_Altars[TYPECOSMIC].Tile,Bot.OB_Altars[TYPECHAOS].Tile,Bot.OB_Altars[TYPENATURE].Tile,
    Bot.OB_Altars[TYPELAW].Tile,Bot.OB_Altars[TYPEDEATH].Tile,Bot.OB_Altars[TYPEBLOOD].Tile,
    Bot.OB_ExitPortal.Tile:
      if InRange(Bot.GetAltarLoc, TYPEAIR, TYPEBLOOD) then
        Exit(True)
      else
        Exit(False);
  end;
end;

function TMSObject.Find: Boolean;
  function GetObjPt: TPoint;
  var
    B: TBox;
    i: Int32;
    Rect: TRectangle;
    ATPA: T2DPointArray;
    Finder: TRSObjectFinder;
  begin
    for i:=0 to High(Self.Colors) do
      Finder.Colors += Self.Colors[i];

    Finder.ClusterDistance := 10;

    Rect := Bot.RSW.GetTileMSEx(Bot.RSW.GetMyPos, Self.Tile);
    Rect := Rect.Expand(Self.Expand);
    B    := Rect.Bounds;

    B.LimitTo(MainScreen.Bounds);
    if MainScreen.IsVisible(B.Middle()) then
    begin
      ATPA := MainScreen.FindObject(Finder, B);
      if (ATPA.Len > 0) then
        Result := ATPA.Biggest().Mean();
    end;
  end;

var
  Pt: TPoint;
begin
  Result := False;

  if Inventory.GetSelectedSlot >= 0 then
    ChooseOption.Select('Cancel');

  Pt := GetObjPt;
  if Pt.X<5 then Exit;

  Mouse.Move(Pt);
  Result := MainScreen.IsUpText(Self.UpText, 75);
end;

function TMSObject.Interact(MouseMove:Boolean=True): Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if (not Self.IsReachable) then
  begin
    Bot.FailReason := 'Not reachable';
    Bot.WriteMsg('Not reachable ('+Self.Name+')');
    Exit;
  end;

  if Self.Tile.DistanceTo(Bot.OB_RubbleW.Tile) > 5 then
  begin
    Bot.WalkSearch := True;
    Bot.WalkObj    := Self;
  end;

  if WaitUntil(Self.Find, 75, 300) then
  begin
    Mouse.Click(MOUSE_LEFT);
    Result := MainScreen.DidRedClick;
    if Result then
    begin
      if MouseMove then
      begin
        if SRL.Dice(75) then
          Mouse.RandomMovement;
      end else
        WaitEx(75, 10);

      Bot.FailReason := '';
      Bot.WalkSearch := False;
      Bot.FoundObj   := False;
      Exit;
    end;
  end;

  if (not Bot.RSW.WalkBlind(Self.WalkTile, SRL.NormalRange(3,7))) then
    if (not Bot.FoundObj) then
    begin
      Bot.FailReason := 'Walked to but never found';
      Exit;
    end;

  if Bot.IsObelisk then
    if (Bot.RIndex <> Bot.GetETypeRune) and (Bot.RIndex <> Bot.GetCTypeRune) then
      Exit;

  Bot.WalkSearch := False;
  Bot.FoundObj := False;

  if (Self.Tile = Bot.OB_RubbleW.Tile) then
    Minimap.WaitFlag(5);

  if (not WaitUntil(Self.Find, 75, 300)) then
  begin
    While Minimap.IsPlayerMoving do
    begin
      if Bot.IsObelisk then
        if (Bot.RIndex <> Bot.GetETypeRune) and (Bot.RIndex <> Bot.GetCTypeRune) then
          Exit;

      if Self.Find then
      begin
        Mouse.Click(MOUSE_LEFT);
        if MainScreen.DidRedClick then
        begin
          Bot.FailReason := '';
          WaitEx(75, 10);
          Exit(True);
        end;
      end;
    end;
    if (not WaitUntil(Self.Find, 75, 300)) then
      if Self.WalkTile.DistanceTo(Bot.RSW.GetMyPos) >= 13 then
      begin
        Bot.RSW.WalkBlind(Self.WalkTile);
        if Self.Find then
        begin
          Mouse.Click(MOUSE_LEFT);
          if MainScreen.DidRedClick then
          begin
            Bot.FailReason := '';
            WaitEx(75, 10);
            Exit(True);
          end;
        end;
      end;
  end else
  begin
    Mouse.Click(MOUSE_LEFT);
    Result := MainScreen.DidRedClick;
    if Result then
    begin
      Bot.FailReason := '';
      WaitEx(75, 10);
    end;
  end;

  Bot.FailReason := 'Never found';
end;

procedure TScript.RepairPouches();
var
  i: Int32;
  T: TCountdown;
  Dots: TPointArray;
  NPCs: T2DPointArray;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if Self.CheckMessages then
    Self.Report;

  if DEBUGMODE then
    Self.WriteMsg('Repairing rune pouches');

  if Self.CastSpell then
  begin
    if Self.GetPower = 100 then
    begin
      if DEBUGMODE then
        Self.WriteMsg('Waiting for the game to end before repairing');
      while Self.GetPower = 100 do
      begin
        if (not RSClient.IsLoggedIn) then Exit;
        Antiban.DoAntiban(False, False);
        WaitEx(300, 40);
      end;

      if Self.CheckMessages then
        Self.Report;
    end;

    for 1 to 3 do
    begin
      if Self.CheckMessages then
        Self.Report;
      if Magic.MouseSpell(ERSSpell.NPC_CONTACT) then
      begin
        if ChooseOption.Select('Dark Mage', MOUSE_LEFT, True, True) then
        begin
          if WaitUntil(Chat.ClickContinue, 150, 7000) then
          begin
            if Chat.ChatToOption('repair') then
            begin
              Chat.ClickOption('repair', False);
              if WaitUntil(Chat.ClickContinue, 150, 5000) then
                if WaitUntil((not Self.HasDegradedPouch), 150, 3000) then
                begin
                  if Self.CheckMessages then
                    Self.Report;
                  Exit;
                end;
            end;
          end else
          begin
            if Chat.FindMessage('enough', [CHAT_COLOR_BLACK]) then
            begin
              Logout.ClickLogout;
              TerminateScript('Lacking runes/rune pouch to cast the NPC Contact spell');
            end;
          end;
        end else
        begin
          Mouse.Move(GameTabs.GetTabBox(ERSGameTab.MAGIC));
          if (not ChooseOption.Select('Enable')) then
          begin
            Logout.ClickLogout;
            TerminateScript('Failed to set spell filtering');
          end;
        end;
      end else
      begin
        Logout.ClickLogout;
        TerminateScript('NPC Contact spell not already set to Dark Mage');
      end;
      if Chat.FindMessage('enough', [CHAT_COLOR_BLACK]) then
      begin
        Logout.ClickLogout;
        TerminateScript('Lacking runes/rune pouch to cast the NPC Contact spell');
      end;
    end;
  end else
  begin
    if (not Inventory.ContainsItem('Abyssal pearls')) then
    begin
      if DEBUGMODE then
        Self.WriteMsg('Out of abyssal pearls, disabling pouches');

      Self.CanUsePouches := False;
      Exit;
    end;

    if (not Self.IsInTemple) then
    begin
      if DEBUGMODE then
        Self.WriteMsg('Not in the temple');
      Exit;
    end;

    Self.RSW.WalkBlind([281,190]);
    While Minimap.IsPlayerMoving do
      WaitEx(125, 20);

    if Self.GetPower = 100 then
    begin
      if DEBUGMODE then
        Self.WriteMsg('Waiting for the game to end before repairing');

      if Self.RepairShields then
        Self.TakeCells;

      while Self.GetPower = 100 do
      begin
        if (not RSClient.IsLoggedIn) then Exit;
        Antiban.DoAntiban(False, False);
        WaitEx(300, 40);
      end;
    end;

    for 1 to 3 do
    begin
      Dots := Minimap.GetDots(ERSMinimapDot.NPC);
      Dots := Dots.Offset(2, 2);
      if Length(Dots) < 1 then Continue;
      for i:=0 to High(Dots) do
      begin
        Mouse.Move(Minimap.PointToMsRect(Dots[i]));
        if Mainscreen.IsUpText(Self.NPC_Cordelia.UpText, 125) then
          break;
      end;

      if Mainscreen.IsUpText(Self.NPC_Cordelia.UpText) then
        break;
      if SRL.Dice(75) then
        Antiban.SmallCameraRotation;
      while Minimap.IsPlayerMoving do
        WaitEx(125, 20);
    end;

    if (not Mainscreen.IsUpText(Self.NPC_Cordelia.UpText)) then
      for 1 to 3 do
      begin
        if Self.NPC_Cordelia.Find(NPCs) then
        begin
          NPCs := NPCs.SortFrom(Mainscreen.Center);
          for i:=0 to High(NPCs) do
          begin
            Mouse.Move(NPCs[i].Median);
            if Mainscreen.IsUpText(Self.NPC_Cordelia.UpText, 125) then
              break;
          end;
        end;

        if Mainscreen.IsUpText(Self.NPC_Cordelia.UpText) then
          break;
        if SRL.Dice(75) then
          Antiban.SmallCameraRotation;
        while Minimap.IsPlayerMoving do
          WaitEx(125, 20);
      end;

    if (not Mainscreen.IsUpText(Self.NPC_Cordelia.UpText)) then
    begin
      Self.NPC_Cordelia.Filter  := [True, True, False, True];
      for 1 to 4 do
      begin
        if Self.NPC_Cordelia.Find(NPCs) then
        begin
          NPCs := NPCs.SortFrom(Mainscreen.Center);
          for i:=0 to High(NPCs) do
          begin
            Mouse.Move(NPCs[i].Median);
            if Mainscreen.IsUpText(Self.NPC_Cordelia.UpText, 125) then
              break;
          end;
        end;

        if Mainscreen.IsUpText(Self.NPC_Cordelia.UpText) then
          break;
        if SRL.Dice(75) then
          Antiban.SmallCameraRotation;
        while Minimap.IsPlayerMoving do
          WaitEx(125, 20);
      end;
    end;

    if Mainscreen.IsUpText(NPC_Cordelia.UpText) then
    begin
      Self.NPC_Cordelia.Filter  := [True, True, True, True];
      Mouse.Click(MOUSE_LEFT);
      Minimap.WaitFlag;
      if WaitUntil(Chat.ClickContinue, 150, 7000) then
      begin
        if Chat.ChatToOption('sounds fair') then
        begin
          T.Init(12500);
          while (not T.IsFinished) and (Chat.GetChatTitle <> '') do
          begin
            Chat.ClickContinue;
            WaitEx(125, 20);
          end;
          if (Chat.GetChatTitle = '') then
          begin
            if Self.CheckMessages then
              Self.Report;
            if WaitUntil(Chat.ClickContinue, 150, 12500) then
            begin
              T.Init(12500);
              while (not T.IsFinished) and (Chat.GetChatTitle <> '') do
              begin
                Chat.ClickContinue;
                if (not Self.HasDegradedPouch) then
                begin
                  Self.CanUsePouches := True;
                  if Self.CheckMessages then
                    Self.Report;
                  if Self.RepairShields then
                    Self.TakeCells;
                  Exit;
                end;
                WaitEx(125, 20);
              end;
            end;
          end;
        end;
      end;
    end;

    if DEBUGMODE then
      Self.WriteMsg('Failed to repair essence pouches, disabling');

    Self.CanUsePouches := False;
  end;
end;

function TScript.PeekBarrier(): Boolean;
var
  i: Int32;
  S: String;
  T: TCountdown;
  TSA: TStringArray := ['closed','finishing','calm','recovering','no threat'];
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if DEBUGMODE then
    Self.WriteMsg('Peeking in the barrier');

  if (not Self.OB_Barrier.Find) then
  begin
    Self.RSW.WalkBlind(Self.OB_Barrier.WalkTile);
    if (not Self.OB_Barrier.Find) then Exit;
  end;

  ChooseOption.Open;
  ChooseOption.Select('Peek');

  Minimap.WaitFlag;
  T.Init(SRL.NormalRange(3000,4500));
  while (not T.IsFinished) do
  begin
    S := OCR.Recognize(Chat.Bounds(), TOCRColorFilter.Create([128,$000000]), RS_FONT_QUILL_8);
    for i:=0 to High(TSA) do
      if TSA[i] in S then
        Exit(True);
    WaitEx(250, 50);
  end;
end;

function TScript.HandleBarrier(Enter: Boolean=True): Boolean;
var
  T: TCountdown;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  writeln('Time running(GetTimeRunning): ',GetTimeRunning);
  writeln('ShutdownTime: ',ShutdownTime);
  if Enter then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Attempting to enter the game');
  end else
  begin
    if DEBUGMODE then
      Self.WriteMsg('Exiting the game');
  end;

  Self.OB_Barrier.Interact();
  Minimap.WaitFlag;

  if Enter then
  begin
    if Self.IsInTemple then Exit(True);
    if (not Self.PeekBarrier) then
    begin
      if DEBUGMODE then
        Self.WriteMsg('On-going game, waiting a little while');

      T.Init(SRL.NormalRange(9000, 20000));
      while (not T.IsFinished) do
      begin
        if (not RSClient.IsLoggedIn) then Exit;
        if SRL.Dice(5) then
          Chat.ClickContinue(False);
        Antiban.DoAntiban(False, False);
        WaitEx(250, 75);
      end;

      Exit;
    end;

    T.Init(120000);
    while (not T.IsFinished) do
    begin
      if (not RSClient.IsLoggedIn) then Exit;
      if Self.IsInTemple then Exit(True);
      Self.OB_Barrier.Interact(False);
      if (not Chat.FindOption('Click here to continue', [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE])) then
        break;
      Antiban.DoAntiban(False, False);
      WaitEx(150, 75);
    end;

    Minimap.WaitPlayerMoving;
  end else
  begin
    if WaitUntil(Chat.ClickOption('Yes.'), 150, 4000) then
      if WaitUntil(Minimap.IsPlayerMoving, 150, 3500) then
        Minimap.WaitPlayerMoving;
  end;

  if Enter then
    Result := Self.IsInTemple
  else
    Result := Self.IsInLobby;
end;

function TScript.ExitWestArea(): Boolean;
var
  Clicked,Ended: Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if DEBUGMODE then
    Self.WriteMsg('Exiting the west mining area');

  for 1 to 3 do
  begin
    if Self.OB_WestPortal.Interact then
    begin
      Clicked := True;
      break;
    end;
    case SRL.Dice(50) of
      True:  Minimap.SetCompassAngle(Minimap.GetCompassAngle() - SRL.TruncatedGauss(20, 90, 3));
      False: Minimap.SetCompassAngle(Minimap.GetCompassAngle() + SRL.TruncatedGauss(20, 90, 3));
    end;
  end;

  if (not Clicked) then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Failed to interact with the portal (west mining area)');
    Exit;
  end;

  Ended := (not InRange(Self.GetPower,1,100));
  Minimap.WaitFlag(3);
  While Minimap.IsPlayerMoving do
    WaitEx(125, 20);

  if WaitUntil(Self.IsInTemple, 150, 6000) then
  begin
    if (not Ended) then
      WaitUntil(InRange(Self.GetPower,1,100), 150, 6000);
  end;

  Result := Self.IsInTemple;
end;

function TScript.ExitEastArea(): Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if DEBUGMODE then
    Self.WriteMsg('Exiting the east mining area');

  if (not Self.OB_RubbleE.Interact) then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Failed to interact with the rubble (bottom)');
    Exit;
  end;

  Minimap.WaitFlag(5);
  While Minimap.IsPlayerMoving do
    WaitEx(125, 20);

  if WaitUntil(Minimap.IsPlayerMoving, 150, 4000) then
    While Minimap.IsPlayerMoving do
      WaitEx(125, 20);

  Result := WaitUntil(Self.IsInTemple, 150, 7000);

  if Result then
    While Minimap.IsPlayerMoving do
      WaitEx(125, 20);
end;

function TScript.ExitCurrentAltar(): Boolean;
var
  i: Int32;
  Loc: Int32 := Self.GetAltarLoc;
  SortedPts: TPointArray;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if Self.IsInTemple then Exit;

  if Self.IsInWestArea then
    if (not Self.ExitWestArea) then
    begin
      Logout.ClickLogout;
      TerminateScript('Failed to exit the west mining area');
    end;

  if (not InRange(Loc, TYPEAIR, TYPEBLOOD)) then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Unknown altar location, Pos: '+ToStr(Self.RSW.GetMyPos));

    Exit;
  end;

  if DEBUGMODE then
    Self.WriteMsg('Exiting the '+RuneNames[Loc]+' altar');

  if Self.IsInTemple then Exit;
  Self.WalkObj := Self.OB_ExitPortal;

  if Self.OB_Altars[Loc].ExitTiles.Len > 1 then
  begin
    SortedPts := Self.OB_Altars[Loc].ExitTiles;
    SortedPts.Sort(Self.RSW.GetMyPos());
    Self.OB_ExitPortal.Tile := SortedPts[0];
  end else
    Self.OB_ExitPortal.Tile := Self.OB_Altars[Loc].ExitTiles[0];

  Self.OB_ExitPortal.Colors[0] := Self.OB_Altars[Loc].ExitCol;
  Self.OB_ExitPortal.WalkTile  := Self.OB_ExitPortal.Tile;

  // Because of the extreme tile height swings at the fire altar, we must use a custom walking path
  if Loc = TYPEFIRE then
    Self.RSW.WalkBlind([330,598], SRL.NormalRange(15,25));

  for 1 to 3 do
  begin
    if Self.IsInTemple then
    begin
      WaitUntil((Self.GetETypeRune < INACTIVE) , 150, 5000);
      Exit(True);
    end;
    if Loc = TYPECOSMIC then
    begin
      if Self.RSW.GetMyPos.DistanceTo(Self.OB_Altars[Loc].Tile) > 20 then
        for i:=0 to High(Self.OB_Altars[Loc].ExitTiles) do
        begin
          Self.OB_ExitPortal.Tile := Self.OB_Altars[Loc].ExitTiles[i];
          if WaitUntil(Self.OB_ExitPortal.Find, 75, 750) then
          begin
            Mouse.Click(MOUSE_LEFT);
            if (not MainScreen.DidRedClick) then Continue;
            Minimap.WaitFlag(5);
            if WaitUntil(Self.IsInTemple, 150, 9000) then
              WaitUntil((Self.GetETypeRune < INACTIVE) , 150, 5000);

            Result := Self.IsInTemple;
            if Result then Exit(True);
          end;
        end;

      if Self.OB_ExitPortal.Interact then
      begin
        Minimap.WaitFlag(5);
        if WaitUntil(Self.IsInTemple, 150, 9000) then
          WaitUntil((Self.GetETypeRune < INACTIVE) , 150, 5000);

        Result := Self.IsInTemple;
        if Result then Exit(True);
      end;
    end else
    begin
      if Self.OB_ExitPortal.Interact then
      begin
        Minimap.WaitFlag(20);
        if SRL.Dice(85) then
          if (not Self.IsPortalActive) then
            Mouse.Move(Self.RSW.GetTileMSEx([278+RandomRange(-5,5),184+RandomRange(-5,5)], [278+RandomRange(-5,5),152+RandomRange(-5,5)]));

        if WaitUntil(Self.IsInTemple, 150, 9000) then
          WaitUntil((Self.GetETypeRune < INACTIVE) , 150, 5000);

        Result := Self.IsInTemple;
        if Result then Exit(True);
      end;
    end;
  end;
end;

function TScript.DepositRunes(): Boolean;
var Clicked: Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if (not Self.IsInTemple) then Exit;

  if DEBUGMODE then
    Self.WriteMsg('Depositing runes');

  for 1 to 3 do
    if Self.OB_DepositPool.Interact() then
    begin
      Clicked := True;
      break;
    end else
      Antiban.RandomRotate;

  if (not Clicked) then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Failed to interact with the deposit pool');
    Exit;
  end;

  Minimap.WaitFlag(5);
  Result := WaitUntil((not Self.HasRunes), 75, 5000);
end;

function TScript.ResetPosition(): Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if DEBUGMODE then
    Self.WriteMsg('Resetting to starting position');

  if Self.CanMineEast then
  begin
    if (not Self.IsInEastArea) then
    begin
      for 1 to 3 do
        if Self.OB_RubbleW.Interact then
          break;

      Minimap.WaitFlag(3);
      While Minimap.IsPlayerMoving do
        WaitEx(125, 20);
      if WaitUntil(Minimap.IsPlayerMoving, 150, 4000) then
        While Minimap.IsPlayerMoving do
          WaitEx(125, 20);

      if WaitUntil(Self.IsInEastArea, 75, 5000) then
      begin
        While Minimap.IsPlayerMoving do
          WaitEx(125, 20);
      end else
      begin
        if (Pos('56', Chat.GetChat) <> 0) then
        begin
          Self.WriteMsg('Player is < 56 Agility, adjusting location to mine fragments');
          Self.CanMineEast := False;
          Exit;
        end;
        if (not Self.OB_RubbleW.Interact) then
        begin
          Self.WriteMsg('Error interacting with the rubble (top)');
          Exit;
        end;
      end;
    end;

    Result := Self.IsInEastArea;

    if (not Result) then
    begin
      Self.WriteMsg('Issue taking taking the rubble shortcut');
      Exit;
    end;

    if SRL.Dice(65) then
      Self.RSW.WalkBlind(Self.OB_LargeRemainsS.WalkTile)
    else
      Self.RSW.WalkBlind(Self.OB_LargeRemainsN.WalkTile);
  end else
    Result := Self.RSW.WalkBlind(Self.OB_Remains.WalkTile);

  if Self.HasDegradedPouch then
    if Self.CastSpell then
      Self.RepairPouches;

  WaitEx(100, 25);
end;

function TScript.EnterPortal(): Boolean;
var Clicked: Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if Self.IsInWestArea then Exit;
  if (not Self.IsInTemple) then Exit;
  if InRange(Self.GetAltarLoc, TYPEAIR, TYPEBLOOD) then
    Self.ExitCurrentAltar;

  if DEBUGMODE then
    Self.WriteMsg('Entering the portal');

  Self.IsPortal := True;

  for 1 to 3 do
  begin
    if Self.OB_Portal.Interact() then
    begin
      Clicked := True;
      break;
    end else
      Minimap.WaitFlag(SRL.NormalRange(7,20));

    if (not Self.IsPortalActive) or (not Self.IsInTemple) then
    begin
      if (not Self.IsPortalActive) then
        if DEBUGMODE then
          Self.WriteMsg('Missed the portal, exiting');

      Self.IsPortal := False;
      Exit;
    end;
  end;

  Self.IsPortal := False;
  if (not Clicked) then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Failed to interact with the portal');
    Exit;
  end;

  Minimap.WaitFlag(5);
  if WaitUntil(Self.IsInWestArea, 150, 6000) then
    WaitUntil(InRange(Self.GetETypeRune, TYPEAIR, TYPEBLOOD) , 150, 5000);
  Result := Self.IsInWestArea;
end;

function TScript.Mine(Material: String; Limit: Int32 = -1): Boolean
var
  i,TempPI,Count: Int32;
  MyPos: TPoint;
  T: TCountdown;
  Obj: TMSObject;
  Slots: TIntegerArray;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if Material = 'Essence' then
  begin
    if (not WaitUntil(Self.IsInWestArea, 75, 500)) then Exit;

    if Inventory.IsFull then Exit;
    if DEBUGMODE then
      Self.WriteMsg('Mining essence');

    if SRL.Dice(65) then
      Obj := Self.OB_HugeRemainsS
    else
      Obj := Self.OB_HugeRemainsN;

    if Self.IsGameOver(1500) then
    begin
      if DEBUGMODE then
        Self.WriteMsg('Game over, exiting the west area [1]');

      Exit;
    end;

    TempPI := Self.TempIte;

    if InRange(Self.GetPower, NEAREND, 100) then
      TempPI := Min(1, Self.TempIte);

    for i:=0 to Self.TempIte do
    begin
      for 1 to 2 do
        if Obj.Interact then
        begin
          if SRL.Dice(85) then
          begin
            if Inventory.Finditems(['Small pouch','Medium pouch',5511,'Large pouch',5513,'Colossal pouch',26786], Slots) then
              Inventory.HoverSlot(SRL.TruncatedGauss(Slots[0],Slots[Length(Slots)-1]));
          end else
            Mouse.Move(Inventory.Bounds);

          break;
        end;

      if SRL.Dice(65) then
        Mouse.RandomMovement;

      Minimap.WaitFlag(5);

      Count := Inventory.Count;
      T.Init(6000);
      while (T.TimeRemaining > 0) do
      begin
        if (not RSClient.IsLoggedIn) then Exit;
        if Self.IsGameOver(1500) then
        begin
          if DEBUGMODE then
            Self.WriteMsg('Game over, exiting the west area [2]');

          Exit;
        end;

        Antiban.DoAntiban(False, False);

        if (Pos('pickaxe', Chat.GetChat) <> 0) then
        begin
          Self.WriteMsg('No pickaxe');
          Logout.ClickLogout;
          TerminateScript('Player does not have a pickaxe');
        end;

        if i = TempPI then
        begin
          if Inventory.IsFull then
            break;
        end else
          if Inventory.Count >= SRL.NormalRange(25,28) then
            break;

        if Count <> Inventory.Count then
        begin
          T.Restart();
          Count := Inventory.Count;
        end;

        WaitEx(250,50);
      end;

      if i < TempPI then
        if i>0 then
          Self.HandlePouches(True, True) // Giant pouch only
        else if i<1 then
          Self.HandlePouches;
    end;

    Result := Inventory.IsFull;
    WaitEx(250,50);
  end else if Material = 'Fragments' then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Mining fragments');

    if Self.IsInEastArea() then
    begin
      WaitUntil(Self.GetRemainingTime > 0 , 150, 45000);

      MyPos := Self.RSW.GetMyPos;

      if MyPos.DistanceTo(Self.OB_LargeRemainsN.Tile) < MyPos.DistanceTo(Self.OB_LargeRemainsS.Tile) then
      begin
        if (not Self.OB_LargeRemainsN.Interact) then
          if (not Self.OB_LargeRemainsS.Interact) then
          begin
            if DEBUGMODE then
              Self.WriteMsg('Failed to interact with the large remains object');
            Antiban.RandomRotate;
            Exit;
          end;
      end else
      begin
        if (not Self.OB_LargeRemainsS.Interact) then
          if (not Self.OB_LargeRemainsN.Interact) then
          begin
            if DEBUGMODE then
              Self.WriteMsg('Failed to interact with the large remains object');
            Antiban.RandomRotate;
            Exit;
          end;
      end;

      if SRL.Dice(65) then
        Mouse.RandomMovement;

      Minimap.WaitFlag(5);

      Count := Inventory.CountItemStack('Guardian fragments');
      T.Init(6000);

      while (T.TimeRemaining > 0) do
      begin
        if (not RSClient.IsLoggedIn) then Exit;
        Antiban.DoAntiban(False, False);

        if (Pos('pickaxe', Chat.GetChat) <> 0) then
        begin
          Self.WriteMsg('No pickaxe');
          Logout.ClickLogout;
          TerminateScript('Player does not have a pickaxe');
        end;

        if Chat.FindOption('Click here to continue', [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE]) then
          Obj.Interact;

        if (Inventory.CountItemStack('Guardian fragments') >= Limit) then
          Exit(True);

        if Count <> Inventory.CountItemStack('Guardian fragments') then
        begin
          T.Restart();
          Count := Inventory.CountItemStack('Guardian fragments');
        end;

        waitEx(250,50);
      end;

      Result := (Inventory.CountItemStack('Guardian fragments') >= Limit);
      waitEx(250,50);
    end else
    begin
      if (not Self.OB_Remains.Interact) then
      begin
        if DEBUGMODE then
          Self.WriteMsg('Failed to interact with the remains object');
        Exit;
      end;

      Minimap.WaitFlag(5);
      Count := Inventory.CountItemStack('Guardian fragments');

      T.Init(6000);
      while (T.TimeRemaining > 0) do
      begin
        if (not RSClient.IsLoggedIn) then Exit;
        if Inventory.Count < 27 then
          if Self.IsPortalActive then
            Exit;

        Antiban.DoAntiban(False, False);

        if (Pos('pickaxe', Chat.GetChat) <> 0) then
        begin
          Self.WriteMsg('No pickaxe');
          Logout.ClickLogout;
          TerminateScript('Player does not have a pickaxe');
        end;

        if Chat.FindOption('Click here to continue', [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE]) then
          if (not Self.OB_Remains.Interact) then
          begin
            if DEBUGMODE then
              Self.WriteMsg('Failed to interact with the remains object');
            Exit;
          end;

        if Limit <> -1 then
        begin
          if (not InRange(Self.GetPower,1,99)) then Exit;
          if (Inventory.CountItemStack('Guardian fragments') >= Limit) then
            break;

          if InRange(Self.GetPower, NEAREND, 100) then // Nearing the end of a game
            if Inventory.CountItemStack('Guardian fragments') >= 25 then
            begin
              Result := True;
              waitEx(250,50);
              Exit;
            end;
        end;

        if Self.CatalyticOnly then
        begin
          Self.RIndex := Self.GetCTypeRune;
          if Self.CanCraftRunes(Self.RIndex) then
            if Inventory.Count >= 26 then
              Exit;
        end;

        if ((FORCEBALANCE) and (Self.GetEnergyDiff >= 50)) then
        begin
          Self.RIndex := Self.GetCTypeRune;
          if Self.CanCraftRunes(Self.RIndex) then
            if Inventory.Count >= 26 then
              Exit;
        end;

        if Count <> Inventory.CountItemStack('Guardian fragments') then
        begin
          T.Restart();
          Count := Inventory.CountItemStack('Guardian fragments');
        end;

        waitEx(250,50);
      end;

      Result := (Inventory.CountItemStack('Guardian fragments') >= Limit);
      waitEx(250,50);
    end;
  end;
end;

function TScript.CraftEssence(): Boolean
var
  i: Int32;
  T: TCountdown;
  Slots: TIntegerArray;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if Self.GetPower = 100 then Exit;

  if Self.IsPortalActive then
    if (not InRange(Self.GetPower, NEAREND, 100)) then
      if (Inventory.Count < 26) then
        Exit;

  if Self.HasRunes then
    Self.DepositRunes;

  if DEBUGMODE then
    Self.WriteMsg('Crafting essence');

  for i:=0 to Self.TempIte do
  begin
    for 1 to 2 do
    begin
      if Self.OB_Workbench.Interact then
        break;
      if Self.IsPortalActive then
        if (Inventory.Count < 26) then
          Exit;
    end;

    if SRL.Dice(65) then
      Mouse.RandomMovement;

    Minimap.WaitFlag(5);

    T.Init(20000);
    while (T.TimeRemaining > 0) do
    begin
      if (not RSClient.IsLoggedIn) then Exit;
      if Self.IsPortalActive then
        if (i < Self.TempIte) and (Inventory.Count < 26) then
          Exit;

      if Chat.ClickContinue then Exit;
      Antiban.DoAntiban(False, False);
      if (Inventory.CountItemStack('Guardian fragments') < 1) then
        break;
      if Inventory.Count >= SRL.NormalRange(23, 28) then
        if SRL.Dice(85) then
        begin
          if Inventory.Finditems(['Small pouch','Medium pouch',5511,'Large pouch',5513,'Colossal pouch',26786], Slots) then
            Inventory.HoverSlot(SRL.TruncatedGauss(Slots[0],Slots[Length(Slots)-1]));
        end else
          Mouse.Move(Inventory.Bounds);
      if Inventory.IsFull then
        break;
      WaitEx(200,60);
    end;

    if (Inventory.CountItemStack('Guardian fragments') < 1) then
      Exit;

    if InRange(Self.GetPower, NEAREND, 100) then
      break;

    if i < Self.TempIte then
      if i > 0 then
        Self.HandlePouches(True, True) // Giant pouch only
      else if i<1 then
        Self.HandlePouches;
  end;

  Result := Inventory.IsFull;

  if Result then
    if Self.IsGameOver then
    begin
      if DEBUGMODE then
        Self.WriteMsg('Game over while crafting essence');
      if Self.CheckMessages then
        Self.Report;
      T.Init(20000);
      while (T.TimeRemaining > 0) do
      begin
        if Self.GetETypeRune <> INACTIVE then break;
        Antiban.DoAntiban(False, False);
        WaitEx(200, 70);
      end;
    end;
end;

function TScript.EnterObelisk(): Boolean
var
  T: TCountDown;
  Clicked: Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if (not Self.IsInTemple) then Exit;

  if (not Self.CatalyticOnly) then
  begin
    if Self.GetEEnergy >= Self.GetCEnergy then
    begin
      Self.RIndex := Self.GetCTypeRune;
      if (not InRange(Self.RIndex, TYPEMIND, TYPEBLOOD)) then Exit;
      if (not Self.CanCraftRunes(Self.RIndex)) then
      begin
        if ((FORCEBALANCE) and (Self.GetEnergyDiff >= 50))  then
        begin
          if DEBUGMODE then
            Self.WriteMsg('Waiting for an available catalytic obelisk to open');
          Exit;
        end else
          Self.RIndex := Self.GetETypeRune;
      end;
    end else
      Self.RIndex := Self.GetETypeRune;
  end else
  begin
    Self.RIndex := Self.GetCTypeRune;
    if (not Self.CanCraftRunes(Self.RIndex)) then
      Exit;
  end;

  if (not InRange(Self.RIndex, TYPEAIR, TYPEBLOOD)) then Exit;

  if Self.GetRemainingTime < 7 then
    if Distance(Self.RSW.GetMyPos, Self.OB_Obelisks[Self.RIndex].Tile) > 25 then
    begin
      if DEBUGMODE then
        Self.WriteMsg('Waiting for the obelisk change');

      while Self.GetRemainingTime < 7 do
      begin
        if (not RSClient.IsLoggedIn) then Exit;
        if Self.IsGameOver(1500) then
          Exit;

        Antiban.DoAntiban(False, False);

        WaitEx(250, 50);
      end;
      Exit;
    end;

  if DEBUGMODE then
    Self.WriteMsg('Entering the '+RuneNames[Self.RIndex]+' obelisk');

  Self.IsObelisk := True;

  for 1 to 3 do
  begin
   if (Self.RIndex <> Self.GetETypeRune) and (Self.RIndex <> Self.GetCTypeRune) then
    begin
      Self.IsObelisk := False;
      Exit;
    end;
    if Self.OB_Obelisks[Self.RIndex].Interact then
    begin
      Clicked := True;
      break;
    end;
  end;

  Self.IsObelisk := False;

  if (not Clicked) then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Failed to interact with the '+RuneNames[Self.RIndex]+' obelisk');
    Exit;
  end;

  Minimap.WaitFlag(5);
  T.Init(7500);
  while T.TimeRemaining > 0 do
  begin
    if Chat.FindOption('Click here to continue', [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE]) then
      Exit;
    if (not Self.IsInTemple) then break;
    WaitEx(150,50);
  end;

  Result := (not Self.IsInTemple);
  T.Init(5500);
  while T.TimeRemaining > 0 do
  begin
    if InRange(Self.GetETypeRune, TYPEAIR, TYPEBLOOD) then
      break;

    WaitEx(75, 10);
  end;

  if (not Result) then
    if Self.IsGameOver(1500) then
      if DEBUGMODE then
        Self.WriteMsg('Game ended after entering the '+RuneNames[Self.RIndex]+' obelisk');

  WaitEx(75, 10);
end;

function TScript.CraftRunes(): Boolean
var
  h,i,Loc,TempPI: Int32;
  B: TBox;
  HP: Boolean;
  MSPnt: TPoint;
  Slots: TIntegerArray;
  CosPath: TPointArray;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if Self.IsInTemple then Exit;

  Loc := Self.GetAltarLoc;

  if (not InRange(Loc, TYPEAIR, TYPEBLOOD)) then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Unknown altar location. Pos: '+ToStr(Self.RSW.GetMyPos));
    Exit;
  end;

  if DEBUGMODE then
    Self.WriteMsg('Crafting '+RuneNames[Loc]+' runes');

  if Loc = TYPECOSMIC then
  begin
    if WaitUntil(Self.GetCosmicCenter.X > 5, 75, 3000) then
    begin
      CosPath := TPAFromLine(Minimap.Center, Self.GetCosmicCenter);
      for i:=High(CosPath) downto 0 do  // SPS FTW
      begin
        B := Minimap.PointToMSRect(CosPath[i], Minimap.GetCompassAngle(False)).Bounds;
        if MainScreen.IsVisible(B.Middle) then
        begin
          for 1 to 5 do
          begin
            MSPnt := SRL.RandomPoint(B);
            Mouse.Move(SRL.RandomPoint(B));
            if MainScreen.IsUpText('Walk here', 50) then
            begin
              Mouse.Click(MOUSE_LEFT);
              if Minimap.HasFlag(500) then break;
            end;
          end;

          if Minimap.HasFlag(150) then break;
        end;
      end;
    end else
    begin
      if WaitUntil(Self.GetCosmicWalkway.X > 5, 75, 500) then
      begin
        for 1 to 3 do
        begin
          Mouse.Click(Self.GetCosmicWalkway, MOUSE_LEFT);
          if Minimap.HasFlag(500) then
          begin
            Minimap.WaitFlag();
            break;
          end;
        end;

        if WaitUntil(Self.GetCosmicCenter.X > 5, 75, 3000) then
        begin
          CosPath := TPAFromLine(Minimap.Center, Self.GetCosmicCenter);
          for i:=High(CosPath) downto 0 do  // SPS FTW
          begin
            B := Minimap.PointToMSRect(CosPath[i], Minimap.GetCompassAngle(False)).Bounds;
            if MainScreen.IsVisible(B.Middle) then
            begin
              MSPnt := SRL.RandomPoint(B);
              break;
            end;
          end;
        end else
        begin
          if DEBUGMODE then
            Self.WriteMsg('Failed to craft '+RuneNames[Loc]+' runes[0], pos: '+ToStr(Self.RSW.GetMyPos));

          Self.ExitCurrentAltar;
          Exit;
        end;
      end else
      begin
        if DEBUGMODE then
          Self.WriteMsg('Failed to craft '+RuneNames[Loc]+' runes[1], pos: '+ToStr(Self.RSW.GetMyPos));

        Self.ExitCurrentAltar;
        Exit;
      end;
    end;

    Minimap.WaitFlag();
  end;

  if Self.OB_Altars[Loc].MidTile.X > 0 then
    Self.RSW.WalkBlind(Self.OB_Altars[Loc].MidTile, SRL.NormalRange(15,25));

  TempPI := Self.TempIte;

  if InRange(Self.GetPower, NEAREND, 100) then
    TempPI := Min(1, Self.TempIte);

  for h:=1 to 3 do
  begin
    if Self.OB_Altars[Loc].Interact(SRL.Dice(15)) then
    begin
      Minimap.HasFlag(100);
      if TempPI > 0 then
        if SRL.Dice(75) then
        begin
          Minimap.WaitFlag(SRL.NormalRange(12,23));
          if SRL.Dice(85) then
          begin
            if Inventory.Finditems(['Small pouch','Medium pouch',5511,'Large pouch',5513,'Colossal pouch',26786], Slots) then
              Inventory.HoverSlot(SRL.TruncatedGauss(Slots[0],Slots[Length(Slots)-1]));
          end else
            Mouse.Move(Inventory.Bounds);
        end;

      Minimap.WaitPlayerMoving;
      if (not WaitUntil((not Inventory.ContainsItem('Guardian essence')), 150, 5000)) then
        Continue;

      if TempPI > 0 then
      begin
        for i:=1 to TempPI do
        begin
          if i = 2 then
            HP := Self.HandlePouches(True, False) // Giant pouch only
          else
            HP := Self.HandlePouches(False, False);

          if HP then
          begin
            for 1 to 3 do
              if Self.OB_Altars[Loc].Interact(False) then
              begin
                Chat.LeveledUp;
                break;
              end;

            if (not FASTMODE) then
            begin
              WaitUntil((not Inventory.ContainsItem('Guardian essence')), 150, 4000);
              Wait(SRL.NormalRange(750, 1000));
            end else
              WaitEx(250, 50);
          end;
        end;
      end;

      if (not FASTMODE) then
        Result := WaitUntil((not Inventory.ContainsItem('Guardian essence')), 150, 4000)
      else
        Result := True;
      if Result then Break;
    end else
      Minimap.WaitPlayerMoving;
    if h:=3 then
      if DEBUGMODE then
      begin
        Self.WriteMsg('Failed to interact with the '+RuneNames[Loc]+' altar');
        Self.WriteMsg('Reason: '+Self.FailReason);
      end;
  end;

  if (not Result) then
    if DEBUGMODE then
      Self.WriteMsg('Failed to craft '+RuneNames[Loc]+' runes[2], pos: '+ToStr(Self.RSW.GetMyPos));

  Self.ExitCurrentAltar;
end;

function TScript.TakeCells(): Boolean;
var
  T: TCountdown;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if Inventory.CountItemStack('Uncharged cell') > 8 then Exit;

  if DEBUGMODE then
    Self.WriteMsg('Grabbing some uncharged cells');

  Self.RSW.WalkBlind(Self.OB_CellBench.WalkTile, 10);
  for 1 to 3 do
    if Self.OB_CellBench.Find then break;

  if (not Mainscreen.IsUpText(Self.OB_CellBench.UpText, 150)) then Exit;

  ChooseOption.Open;
  ChooseOption.Select('e-10');

  Minimap.HasFlag(1200);
  Minimap.WaitFlag(5);
  Minimap.WaitPlayerMoving;

  T.Init(SRL.NormalRange(4500,6000));
  while (not T.IsFinished) do
  begin
    if Inventory.ContainsItem('Uncharged cell') then break;
    WaitEx(250, 50);
  end;

  Result := Inventory.ContainsItem('Uncharged cell');
end;

function TScript.RepairShield(): Boolean;
var
  Clicked: Boolean;
  Shield: TMSObject;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if (not Self.IsInTemple) then Exit;
  Self.DropStuff();
  if DEBUGMODE then
    Self.WriteMsg('Repairing the shield');

  if SRL.Dice(65) then
    Shield := Self.OB_ShieldN
  else
  begin
    if SRL.Dice(50) then
      Shield := Self.OB_ShieldNW
    else
      Shield := Self.OB_ShieldNE;
  end;

  for 1 to 3 do
    if Shield.Interact then
    begin
      Clicked := True;
      break;
    end else
      Antiban.RandomRotate;

  if (not Clicked) then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Failed to repair the shield');
    Exit;
  end;

  if SRL.Dice(65) then
    Mouse.RandomMovement;

  Minimap.WaitFlag(5);
  Result := WaitUntil((not Self.HasChargedCell), 75, 5000);
  WaitEx(100, 20);
end;

function TScript.PowerupGuardian(): Boolean;
var Clicked: Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if (not Self.IsInTemple) then Exit;
  if (Self.GetETypeRune = INACTIVE) and (Self.GetCTypeRune = INACTIVE) then Exit;

  if DEBUGMODE then
    Self.WriteMsg('Powering up the Great Guardian');

  for 1 to 3 do
    if Self.OB_GreatGuardian.Interact then
    begin
      Clicked := True;
      break;
    end;

  if (not Clicked) then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Failed to interact with the Great Guardian');
    Exit;
  end;

  if SRL.Dice(65) then
    Mouse.RandomMovement;

  Minimap.WaitFlag(5);
  Result := WaitUntil((not Self.HasGuardStones), 75, 5000);

  Self.DropStuff;

  if Self.HasChargedCell then
    Self.RepairShield;

  WaitEx(100, 20);
end;

procedure TScript.WaitForStart();
var
  T: TCountDown;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if InRange(Self.GetAltarLoc, TYPEAIR, TYPEBLOOD) then Exit;

  if Self.CheckMessages then
    Self.Report;

  if Self.HasDegradedPouch then
    if (not Self.CastSpell) then
    begin
      Self.RepairPouches;
      if Self.CheckMessages then
        Self.Report;
    end;

  if (not Self.IsRunning) then
  begin
    Self.WriteMsg('Exiting the game to shut down');
    Exit;
  end;

  if Self.RepairShields then
    Self.TakeCells;

  for 1 to 3 do
    if Self.ResetPosition then
      break;

  if WaitUntil((Self.GetPower <> 100), 150, 10000) then
    if Self.CheckMessages then
      Self.Report;

  if DEBUGMODE then
    Self.WriteMsg('Waiting for game to begin');

  if Self.HasDegradedPouch then
    if Self.CastSpell then
      Self.RepairPouches;

  T.Init(85000);
  while T.TimeRemaining > 0 do
  begin
    if (not RSClient.IsLoggedIn) then Exit;
    Chat.ClickContinue(False);
    Antiban.DoAntiban(False, False);

    if (Chat.FindMessage('The rift becomes active!', [2101487]) or (Chat.FindMessage('2...', [CHAT_COLOR_BLACK]))) then
    begin
      Self.GameOver := False;
      Exit;
    end;

    if Self.CheckMessages then
      Self.Report;

    if Self.GetPower > 0 then
      if (Self.GetETypeRune <> INACTIVE) then
      begin
        Self.ExitEastArea;
        Exit;
      end;

    WaitEx(115,25);
  end;
end;
{
// The traditional "WalkPath" but using a different formula for building paths
function TRSWalker.WalkPath(Path: TPointArray; WaitUntilDistance: Int32 = 0): Boolean; override;
  function BuildPath(TPA: TPointArray): TPointArray;
  var
    i,j: Int32;
    Line: TPointArray;
  begin
    if EXPERIMENTALWALK then
    begin
      for i := 1 to High(TPA) do
        Result += TPABetweenPoints(TPA[i-1], TPA[i], 15 + Random(-7,7), 7);
    end else
    begin
      for I := 1 to High(TPA) do
      begin
        Line := TPAFromLine(TPA[I-1], TPA[I]);

        J := 0;
        while J < High(Line) do
        begin
          Result += Line[J];

          // keep the steps low, as mainscreen walking might just have a few tiles visible when NearZoomMode is set True
          if (Self.NearZoomMode) and ((Self.ScreenWalk) or (Self.AdaptiveWalk)) then
            Inc(J, Random(1, 4))
          else
            Inc(J, Random(3, 12));
        end;
      end;

      Result += TPA[High(TPA)];
    end;
  end;

  function AdvancePath(var Index: Int32; PlayerPoint: TPoint): Boolean;
  var
    Angle: Double := Minimap.GetCompassAngle(False);
    Previous: Int32 := Index;
    Nearest, Furthest: Int32;
  begin
    Nearest := Self.Path.Find(Self.Path.Sorted(PlayerPoint)[0]);
    Self.PathIndex := Nearest;

    while (Nearest < High(Self.Path)) and (not Self.IsWalkable(Self.Path[Nearest+1], PlayerPoint, Angle)) do
      Inc(Nearest);

    Furthest := Nearest;
    while (Furthest < High(Self.Path)) and Self.IsWalkable(Self.Path[Furthest+1], PlayerPoint, Angle) do
      Inc(Furthest);

    Index := Furthest;

    // do the result check before randomness to avoid false error
    Result := (Index > Previous);

    // 15% chance of randomness else furthest
    if Random() < 0.15 then
      Index := Random(Nearest, Furthest);
  end;

var
  PlayerPoint: TPoint;
  Index, Fails: Int32;
begin
  Self.Enabled := True;
  PlayerPoint  := Self.GetMyPos();
  Self.Path    := BuildPath([PlayerPoint] + Path);

  if Self.AdaptiveWalk then
  begin
    Self.AdaptiveToggleDistances.X := RSW_ADAPTIVE_SCREEN_TOGGLE_DISTANCES.X + Random(-6,6);
    Self.AdaptiveToggleDistances.Y := RSW_ADAPTIVE_SCREEN_TOGGLE_DISTANCES.Y + Random(-16,16);
    Self.AdaptiveWalkCheck(PlayerPoint);
  end;

  while Self.Enabled and (Fails < 10) do
  begin
    PlayerPoint := Self.GetMyPos();

    if AdvancePath(Index, PlayerPoint) then
      Fails := 0
    else
    begin
      Inc(Fails);

      // Likely haven't moved far enough to advance to next point
      if (Fails < 5) then
      begin
        Wait(300);
        Continue;
      end else begin
        // screen walking struggles, so disable it
        if Self.AdaptiveWalk then
          Self.ScreenWalk := False
        else if (Fails = 5) then
          case SRL.Dice(50) of
            True:  Minimap.SetCompassAngle(Minimap.GetCompassAngle() - SRL.TruncatedGauss(30, 360, 3));
            False: Minimap.SetCompassAngle(Minimap.GetCompassAngle() + SRL.TruncatedGauss(30, 360, 3));
          end;
      end;

      if (Fails mod 2 = 0) then
        Minimap.WaitFlag();
    end;

    if Distance(PlayerPoint, Self.Path[Index]) <= 20 then // The next step is very close, let's just MS walk
      Self.ScreenWalk := True;

    if Index = High(Self.Path) then
    begin
      if Self.WalkFinalStep(PlayerPoint, Self.Path[Index], WaitUntilDistance) then
        Exit(True);
    end else
      Self.WalkStep(PlayerPoint, Self.Path[Index]);
  end;

  if Fails = 10 then
    Self.DebugLn('Failed to advance path');
end;
}
procedure OnWalkEvent(Sender: PRSWalker; Position: TPoint; Destination: TPoint);
begin
  if (not Bot.WalkObj.IsReachable) then
  begin
    Sender^.Enabled := False;
    WaitEx(115, 15);
    Exit;
  end;

  if Bot.WalkSearch then
  begin
    if Bot.IsObelisk then
    begin
      if (Bot.RIndex <> Bot.GetETypeRune) and (Bot.RIndex <> Bot.GetCTypeRune) then
      begin
        Sender^.Enabled := False;
        WaitEx(115, 15);
        Exit;
      end;
    end;

    if Bot.IsPortal then
    begin
      if (not Bot.IsInTemple) then
      begin
        Sender^.Enabled := False;
        WaitEx(115, 15);
        Exit;
      end;
    end;

    if Bot.WalkObj.Find then
    begin
      Bot.FoundObj := True;
      Sender^.Enabled := False;
      WaitEx(115, 15);
    end;

    if Bot.IsPortalActive then
      if Bot.IsInTemple then
        if (Inventory.Count < 26) then
        begin
          Sender^.Enabled := False;
          WaitEx(115, 15);
          Exit;
        end;
  end;

  if SRL.Dice(5) then
    Mouse.RandomMovement;

  if EXPERIMENTALWALK then
    Sender^.ScreenWalk := SRL.Dice(35);

  Bot.DropStuff;

  Position    := [];
  Destination := [];
end;

function TScript.GetState(): EState;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  Result := EState.WAITING;

  if Self.IsInTemple then
  begin
    if Self.HasGuardStones then
    begin
      if InRange(Self.GetPower, 95, 100) then
        Exit(EState.POWERUP);
      if Inventory.Count < 26 then
        if Self.IsPortalActive then
          Exit(EState.GATHER_ESSENCE);

      if Self.GetPower = 0 then
      begin
        if Self.LossStreak >= 3 then
          Exit(EState.CHANGE_WORLDS)
        else
        begin
          if Chat.FindMessage('defeated', [2101487]) then
            if DEBUGMODE then
              Self.WriteMsg('Great Guardian defeated while in the temple [0]');

          Exit(EState.NEW_GAME);
        end;
      end;

      Exit(EState.POWERUP);
    end;

    if (not InRange(Self.GetPower, 1, 99)) then
    begin
      if Self.LossStreak >= 3 then
        Exit(EState.CHANGE_WORLDS)
      else
        Exit(EState.NEW_GAME)
    end;

    if Inventory.Count < 26 then
    begin
      if Self.IsPortalActive then
        if (Self.GetPower < 95) then
          Exit(EState.GATHER_ESSENCE);
    end else if Inventory.Count >= 26 then
    begin
      if Self.CatalyticOnly then
      begin
        Self.RIndex := Self.GetCTypeRune;
        if Self.CanCraftRunes(Self.RIndex) then
          Exit(EState.CRAFT_RUNES)
        else
          Exit(EState.GATHER_FRAGMENTS);
      end;

      if ((FORCEBALANCE) and (Self.GetEnergyDiff >= 50)) then
      begin
        Self.RIndex := Self.GetCTypeRune;
        if Self.CanCraftRunes(Self.RIndex) then
          Exit(EState.CRAFT_RUNES)
        else
        begin
          if DEBUGMODE then
            Self.WriteMsg('Cannot craft '+RuneNames[Self.RIndex]+' runes');
          Exit(EState.GATHER_FRAGMENTS);
        end;
      end;

      Exit(EState.CRAFT_RUNES);
    end;

    if InRange(Self.GetPower, NEAREND, 100) then // Nearing the end of a game
    begin
      if Inventory.ContainsItem('Guardian essence') then
        Exit(EState.CRAFT_RUNES);
      if (Inventory.CountItemStack('Guardian fragments') >= 25) then
        Exit(EState.CRAFT_ESSENCE);
    end;

    if (Inventory.CountItemStack('Guardian fragments') >= Self.EssLimit) then
      Exit(EState.CRAFT_ESSENCE)
    else
      Exit(EState.GATHER_FRAGMENTS);
  end;

  if Self.IsInWestArea then
  begin
    if (not InRange(Self.GetPower, 1, 99)) then
      if Self.LossStreak >= 3 then
        Exit(EState.CHANGE_WORLDS)
      else
      begin
        if Chat.FindMessage('defeated', [2101487]) then
          if DEBUGMODE then
            Self.WriteMsg('Great Guardian defeated while in the west mining area');
        Exit(EState.NEW_GAME);
      end;

    Exit(EState.GATHER_ESSENCE);
  end;

  if Self.IsInEastArea then
    Exit(EState.GATHER_FRAGMENTS);

  if Self.IsInLobby or Box(303,201,332,245).Contains(Self.RSW.GetMyPos) then
    Exit(EState.ENTER_GAME);

  if InRange(Self.GetAltarLoc, TYPEAIR, TYPEBLOOD) then
  begin
    if Inventory.ContainsItem('Guardian essence') then
      Exit(EState.CRAFT_RUNES)
    else
      Exit(EState.EXIT_ALTAR);
  end;

  Self.WriteMsg('Unknown state. Power: '+ToStr(Self.GetPower)+', Time: '+ToStr(Self.GetRemainingTime)+', Loc: '+ToStr(Self.RSW.GetMyPos));
end;

procedure TScript.Run();
var
  CurState: EState;
  EarlyBreak: Boolean;
begin
  While Self.IsRunning do
  begin
    if (not RSClient.IsLoggedIn) then
    begin
      if Login.GetPlayer.Password <> '' then
        Login.LoginPlayer
      else
      begin
        Logout.ClickLogout();
        TerminateScript('No player credentials');
      end;
    end;

    CurState := Self.GetState;
    if DEBUGMODE then
      writeln('[State]: ',CurState);

    case CurState of
      EState.ENTER_GAME: Self.HandleBarrier;
      EState.NEW_GAME:
      begin
        if Self.CheckMessages then
          Self.Report;

        if Self.IsInWestArea then
        begin
          Self.ExitWestArea;
          if Self.CheckMessages then
            Self.Report;
        end;

        if Self.IsInTemple then
        begin
          if Self.HasRunes then
          begin
            Self.DepositRunes;
            if Self.CheckMessages then
              Self.Report;
          end;
        end else
          Self.ExitCurrentAltar;

        while Self.GetPower = 100 do
        begin
          if (not RSClient.IsLoggedIn) then Exit;
          Antiban.DoAntiban(False, False);
          WaitEx(300, 40);
        end;

        Self.IsRunning := GetTimeRunning() < Self.ShutdownTime;

        if Self.TakeBreaks or Self.TakeSleeps then
        begin
          if Self.TakeBreaks then
            EarlyBreak := ((Antiban.Breaks[0].NextAtTime - GetTimeRunning()) < 600000); // < 10 mins until the next break
          if Self.TakeSleeps then
            if (not EarlyBreak) then
              EarlyBreak := ((Antiban.Sleeps[0].NextAtTime - GetTimeRunning()) < 600000); // < 10 mins until the next sleep

          if EarlyBreak then
          begin
            if Self.HasDegradedPouch then
              if (not Self.CastSpell) then
              begin
                Self.RepairPouches;
                if Self.CheckMessages then
                  Self.Report;
              end;

            if DEBUGMODE then
              Self.WriteMsg('Taking a break before the next game begins');

            if (Self.GetPower <> 100) then
              if Self.CheckMessages then
                Self.Report;

            if Self.IsInEastArea then
              Self.ExitEastArea;

            if (Self.GetPower = 100) then
            begin
              WaitUntil((Self.GetPower <> 100), 250, 15000);
              if Self.CheckMessages then
                Self.Report;
            end;

            Self.HandleBarrier(False);

            if Self.TakeBreaks then
              if (Antiban.Breaks[0].NextAtTime - GetTimeRunning()) < 600000 then
                Antiban.Breaks[0].NextAtTime := GetTimeRunning();
            if Self.TakeSleeps then
              if (Antiban.Sleeps[0].NextAtTime - GetTimeRunning()) < 600000 then
                Antiban.Sleeps[0].NextAtTime := GetTimeRunning();

            WaitEx(2500, 150);
            Antiban.DoAntiban;
          end;
        end;

        if Self.IsRunning then
          Self.WaitForStart;
      end;
      EState.GATHER_FRAGMENTS:
      begin
        if Self.IsInEastArea then
        begin
          if Inventory.CountItemStack('Guardian fragments') >= Self.FragsToMine then
            Self.ExitEastArea
          else
            Self.Mine('Fragments', Self.FragsToMine);
        end else
        begin
          if Self.HasRunes then
            Self.DepositRunes;

          if (Self.GetETypeRune = INACTIVE) and (Self.GetCTypeRune = INACTIVE) then
            Self.Mine('Fragments', Self.FragsToMine)
          else
          begin
            if (Self.CatalyticOnly or ((FORCEBALANCE) and (Self.GetEnergyDiff >= 50))) then
            begin
              if Inventory.Count >= 26 then
                Self.Mine('Fragments', -1)
              else
                Self.Mine('Fragments', Self.EssLimit+SRL.NormalRange(4, 10));
            end else
            begin
              if InRange(Self.GetPower, NEAREND, 100) then // Nearing the end of a game
              begin
                if (Self.CatalyticOnly or ((FORCEBALANCE) and (Self.GetEnergyDiff >= 50))) then
                begin
                  Self.RIndex := Self.GetCTypeRune;
                  if (not Self.CanCraftRunes(Self.RIndex)) then
                    Self.Mine('Fragments', -1);
                end else
                  Self.Mine('Fragments', 25+SRL.NormalRange(4, 10));
              end else
                Self.Mine('Fragments', Self.EssLimit+SRL.NormalRange(4, 10));
            end;
          end;
        end;
      end;
      EState.GATHER_ESSENCE:
      begin
        if (not Self.IsInWestArea) then
          if Self.IsPortalActive then
            if (not Self.EnterPortal) then
              Continue;

        if Self.IsInWestArea then
        begin
          if Inventory.IsFull then
            Self.ExitWestArea
          else
            Self.Mine('Essence');
        end;
      end;
      EState.CRAFT_ESSENCE: Self.CraftEssence;
      EState.POWERUP: Self.PowerupGuardian;
      EState.CRAFT_RUNES:
      begin
        if Self.IsInTemple then
          for 1 to 3 do
            if Self.EnterObelisk then break;

        Self.CraftRunes;
      end;
      EState.EXIT_ALTAR: Self.ExitCurrentAltar;
      EState.CHANGE_WORLDS:
      begin
        Self.HandleBarrier(False);
      end;
    end;

    WaitEx(250, 50);
  end;

  if (Self.GetPower <> 100) then
    if Self.CheckMessages then
      Self.Report;

  Self.HandleBarrier(False);

  Self.WriteMsg('Time to shutdown');
  //Logout.ClickLogout();
end;

procedure TScript.Free();
begin
  RSClient.Image.Clear();
  Self.WriteMsg('Thanks for using Flight'#39's AeroGuardians!');
end;

procedure TScript.Init(maxTime: UInt64);
var
  mypos_ : Tpoint;
  Inventory_ : TRSBankItemArray;
  inventoryitems: TRSItemArray;
  i: Int32;
  j: Int32;
  Tiles: TPointArray;
  Lantern: TRSItem;
begin
  Mouse.Speed      := 16 + Antiban.GetBehavior(EBioBehavior.MOUSE_SPEED);
  Mouse.Gravity    := 8  + Round(Antiban.GetBehavior(EBioBehavior.MOUSE_GRAVITY) / 2);
  Mouse.Wind       := 3  + Round(Antiban.GetBehavior(EBioBehavior.MOUSE_WIND) / 2);
  Mouse.MissChance := 9 + Antiban.GetBehavior(EBioBehavior.MOUSE_MISS);
  Mouse.CanIdle    := False;

  Self.SetupAntiban;

  Bot.CastSpell := True;

  RSClient.Image.Clear;

  if (not RSClient.IsLoggedIn) then
    if Login.GetPlayer.Password <> '' then
      Login.LoginPlayer
    else
    begin
      Self.WriteMsg('No player credentials');
      Exit;
    end;

  if SRL.Dice(65) then
  begin
    if SRL.Dice(65) then
    begin
      Options.Open;
      if Options.GetBrightnessLevel < 100 then
        Options.SetMaxBrightness;
      if (not InRange(Options.GetZoomLevel, 10, 40)) then
        Options.SetZoomLevel(SRL.TruncatedGauss(10,40));
      MM2MS.ZoomLevel := Options.GetZoomLevel();

      if Self.CastSpell then
      begin
        Mouse.Move(GameTabs.GetTabBox(ERSGameTab.MAGIC));
        ChooseOption.Select('Enable');
      end;
    end else
    begin
      if Self.CastSpell then
      begin
        Mouse.Move(GameTabs.GetTabBox(ERSGameTab.MAGIC));
        ChooseOption.Select('Enable');
      end;

      Options.Open;
      if Options.GetBrightnessLevel < 100 then
        Options.SetMaxBrightness;
      if (not InRange(Options.GetZoomLevel, 10, 40)) then
        Options.SetZoomLevel(SRL.TruncatedGauss(10,40));
      MM2MS.ZoomLevel := Options.GetZoomLevel();
    end;

    Stats.Open;
    Self.RCLvl       := Stats.GetCurrentLevel(ERSSkill.RUNECRAFTING);
    Self.CanMineEast := Stats.GetCurrentLevel(ERSSkill.AGILITY) >= 56;
  end else
  begin
    Stats.Open;
    Self.RCLvl       := Stats.GetCurrentLevel(ERSSkill.RUNECRAFTING);
    Self.CanMineEast := Stats.GetCurrentLevel(ERSSkill.AGILITY) >= 56;

    if SRL.Dice(65) then
    begin
      Options.Open;
      if Options.GetBrightnessLevel < 100 then
        Options.SetMaxBrightness;
      if (not InRange(Options.GetZoomLevel, 10, 40)) then
        Options.SetZoomLevel(SRL.TruncatedGauss(10,40));
      MM2MS.ZoomLevel := Options.GetZoomLevel();

      if Self.CastSpell then
      begin
        Mouse.Move(GameTabs.GetTabBox(ERSGameTab.MAGIC));
        ChooseOption.Select('Enable');
      end;
    end else
    begin
      if Self.CastSpell then
      begin
        Mouse.Move(GameTabs.GetTabBox(ERSGameTab.MAGIC));
        ChooseOption.Select('Enable');
      end;

      Options.Open;
      if Options.GetBrightnessLevel < 100 then
        Options.SetMaxBrightness;
      if (not InRange(Options.GetZoomLevel, 10, 40)) then
        Options.SetZoomLevel(SRL.TruncatedGauss(10,40));
      MM2MS.ZoomLevel := Options.GetZoomLevel();
    end;
  end;

//INVENTORY
  //SETUP BANK/INVENTORY + ADD REGIONS
  begin
    if Bank.Open(ERSBankLocation.CASTLE_WARS) then
    begin
      Inventory_ += TRSBankItem.Setup('Ring of dueling(1)', 1, False);
      Inventory_[0].Tab := 5; Inventory_[0].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Giant pouch', 1, False);
      Inventory_[1].Tab := 2; Inventory_[1].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Medium pouch', 1, False);
      Inventory_[2].Tab := 2; Inventory_[2].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Small pouch', 1, False);
      Inventory_[3].Tab := 2; Inventory_[3].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Large pouch', 1, False);
      Inventory_[4].Tab := 2; Inventory_[4].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Robe bottoms of the eye', 1, False);
      Inventory_[5].Tab := 2; Inventory_[5].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Robe top of the eye (red)', 1, False);
      Inventory_[6].Tab := 2; Inventory_[6].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Boots of the eye', 1, False);
      Inventory_[7].Tab := 2; Inventory_[7].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Rune pickaxe', 1, False);
      Inventory_[8].Tab := 2; Inventory_[8].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Hat of the eye (red)', 1, False);
      Inventory_[9].Tab := 2; Inventory_[9].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Rune pouch', 1, False);
      Inventory_[10].Tab := 2; Inventory_[10].Scroll := 0;
      Inventory_ += TRSBankItem.Setup(26846, 1, False);
      Inventory_[11].Tab := 2; Inventory_[11].Scroll := 0;


      inventoryitems += 'Giant pouch';
      inventoryitems += 'Small pouch';
      inventoryitems += 'Medium pouch';
      inventoryitems += 'Large pouch';
      inventoryitems += 'Rune pouch';
      Lantern := 26846;

      for i := 0 to High(Inventory_) do
      begin
        Bank.WithdrawItem(Inventory_[i], True);
        Wait(0, 72);
      end;
      //Bank.WithdrawItem(Lantern, True);
    end;
  end;

  while Bank.IsOpen() do
    Bank.Close();

  while not Inventory.IsOpen() do
    Inventory.Open();

  Delete(Inventory_, 11);

  for i := 0 to High(Inventory_) do
  begin
    if not inventoryitems.Contains(Inventory_[i].Item) then
    begin
      Inventory.ClickItem(Inventory_[i].Item);
      Wait(0, 72);
    end;
  end;
  Inventory.ClickItem(Lantern, '');
  wait(200, 560);

//TRAVEL
  Self.RSW.SetupRegions([RSRegions.CASTLE_WARS,RSRegions.GUARDIANS_OF_THE_RIFT]);

  While RSRegions.CASTLE_WARS.Contains(Self.rsw.GetMyPos) do
  begin
    if Grouping.TeleportToActivity("guardians of the rift") then
    begin
      waituntil(rsregions.GUARDIANS_OF_THE_RIFT.Contains(Self.rsw.GetMyPos), 200, 17000);
    end else
    begin
      writeln('Selecting teleport failed');
    end;
  end;
  writeln('Teleported');

  HopOnMinPlayers(5, RSWorldLists.GOTR);

  with Self do
  begin
    RSW.Setup('GotR', 5);
    RSW.OnWalkingEvent := @OnWalkEvent;
    RSW.ScreenWalk := True;

    IsRunning        := True;
    PouchIterations  := 1;
    Inventory.Open;
    EssLimit         := (28-Inventory.Count);
    for 1 to 3 do
    begin
      StartXP := XPBar.Read();
      if StartXP > 0 then break;
      WaitEx(115, 20);
    end;

    if StartXP < 1 then
      Self.WriteMsg('Issue reading the XP bar');

    SetUIBounds(); //TORWENT EDIT
    ChatButtons.ChangeState(ERSChatButton.GAME_CHAT, ERSChatButtonState.FILTERED);
    ChatButtons.Open(ERSChatButton.GAME_CHAT); //TORWENT EDIT

    if Inventory.ContainsItem('Small pouch') then
      EssLimit += 3;
    if Inventory.ContainsAny(['Medium pouch',5511]) then
      EssLimit += 6;
    if Inventory.ContainsAny(['Large pouch',5513]) then
      EssLimit += 9;
    if Inventory.ContainsAny(['Giant pouch',5515]) then
    begin
      EssLimit += 12;
      PouchIterations += 1;
    end;
    if Inventory.ContainsAny(['Colossal pouch',26786]) then
    begin
      EssLimit += 40;
      PouchIterations += 1;
    end;

    TempIte := PouchIterations;
    CanUsePouches := True;

  { Misc. in-game objects }
    with OB_Barrier do
    begin
      Name      := 'Barrier';
      Colors    := [CTS2(16185081, 3, 2.37, 8.50)];
      UpText    := ['Pass Barrier','Barrier'];
      Expand    := 7;
      Tile      := [278,217];
      WalkTile  := [278,217];
    end;
    with OB_Workbench do
    begin
      Name      := 'Workbench';
      Colors    := [CTS2(9803424, 15, 0.11, 0.17)];
      UpText    := ['Work-at','Workbench'];
      Expand    := 7;
      Tile      := [265,201];
      WalkTile  := [265,197];
    end;
    with OB_DepositPool do
    begin
      Name      := 'Deposit pool';
      Colors    := [CTS2(13589296, 14, 0.14, 1.45)];
      UpText    := ['Deposit','-runes'];
      Expand    := 7;
      Tile      := [253,200];
      WalkTile  := [253,195];
    end;
    with OB_GreatGuardian do
    begin
      Name      := 'Great guardian';
      Colors    := [CTS2(8025182, 8, 0.27, 0.52)];
      UpText    := ['Power-up','The Great'];
      Expand    := 7;
      Tile      := [277,132];
      WalkTile  := [277,141];
    end;
    with OB_RubbleW do
    begin
      Name      := 'Rubble (west)';
      Colors    := [CTS2(10200193, 12, 0.11, 0.40)];
      UpText    := ['Climb Rubble','Rubble'];
      Expand    := 5;
      Tile      := [353,135];
      WalkTile  := [347,141];
    end;
    with OB_RubbleE do
    begin
      Name      := 'Rubble (east)';
      Colors    := [CTS2(6973484, 4, 0.06, 0.34)];
      UpText    := ['Climb Rubble','Rubble'];
      Expand    := 5;
      Tile      := [362,136];
      WalkTile  := [366,136];
    end;
    with OB_Portal do
    begin
      Name      := 'Portal';
      Colors    := [CTS2(8249292, 13, 0.58, 2.56)];
      UpText    := ['Portal'];
      Expand    := 5;
      ExitTiles := [[189,135]];
    end;
    with OB_WestPortal do
    begin
      Name      := 'West portal';
      Colors    := [CTS2(8249292, 13, 0.58, 2.56)];
      UpText    := ['Enter','Portal'];
      Expand    := 5;
      Tile      := [189,135];
      WalkTile  := [185,135];
    end;
    with OB_Remains do
    begin
      Name      := 'Remains';
      Colors    := [CTS2(9673850, 8, 0.16, 0.71)];
      UpText    := ['Mine','Guardian'];
      Expand    := 7;
      Tile      := [225,188];
      WalkTile  := [230,188];
    end;
    with OB_HugeRemainsN do
    begin
      Name      := 'Huge remains (north)';
      Colors    := [CTS2(8356936, 7, 0.36, 1.90)];
      UpText    := ['Mine','Huge'];
      Expand    := 7;
      Tile      := [181,114];
      WalkTile  := [184,121];
    end;
    with OB_HugeRemainsS do
    begin
      Name      := 'Huge remains (south)';
      Colors    := [CTS2(9279343, 8, 0.19, 0.96)];
      UpText    := ['Mine','Huge'];
      Expand    := 7;
      Tile      := [181,152];
      WalkTile  := [184,150];
    end;
    with OB_LargeRemainsN do
    begin
      Name      := 'Large remains (north)';
      Colors    := [CTS2(9278808, 11, 0.09, 1.45)];
      UpText    := ['Mine','Large'];
      Expand    := 7;
      Tile      := [377,114];
      WalkTile  := [375,120];
    end;
    with OB_LargeRemainsS do
    begin
      Name      := 'Large remains (south)';
      Colors    := [CTS2(9278808, 11, 0.09, 1.45)];
      UpText    := ['Mine','Large'];
      Expand    := 7;
      Tile      := [375,154];
      WalkTile  := [375,148];
    end;
    with NPC_Cordelia do
    begin
      Setup(20, 1, 4, [[281,190]]);
      Setup(['Apprentice Cordelia']);
      DotType := ERSMinimapDot.NPC;
      Filter  := [True, True, True, True];
      Finder.Colors += CTS2(6778223,18,0.25,0.06);
    end;
    with OB_CellBench do
    begin
      Name      := 'Cell bench';
      Colors    := [CTS2(10331805, 9, 0.18, 0.29)];
      UpText    := ['Uncharged','ed cells'];
      Expand    := 3;
      Tile      := [290,196];
      WalkTile  := [284,192];
    end;
    with OB_ShieldN do
    begin
      Name      := 'North shield';
      Colors    := [CTS2(5989848,10,0.03,1.12), CTS2(9159065,6,0.27,2.01), CTS2(13470852,8,0.07,1.13)];
      UpText    := ['Place-cell'];
      Expand    := 5;
      Tile      := [278,108];
      WalkTile  := [278,114];
    end;
    with OB_ShieldNW do
    begin
      Name      := 'North-west shield';
      Colors    := [CTS2(5989848,10,0.03,1.12), CTS2(9159065,6,0.27,2.01), CTS2(13470852,8,0.07,1.13)];
      UpText    := ['Place-cell'];
      Expand    := 5;
      Tile      := [262,112];
      WalkTile  := [262,118];
    end;
    with OB_ShieldNE do
    begin
      Name      := 'North-east shield';
      Colors    := [CTS2(5989848,10,0.03,1.12), CTS2(9159065,6,0.27,2.01), CTS2(13470852,8,0.07,1.13)];
      UpText    := ['Place-cell'];
      Expand    := 5;
      Tile      := [292,112];
      WalkTile  := [292,118];
    end;
    with OB_ExitPortal do // For altars
    begin
      Name      := 'Altar exit portal';
      Colors    := [CTS2(8563635, 10, 0.17, 0.78)];
      UpText    := ['Use Portal','Portal'];
      Expand    := 10;
    end;

    OB_Obelisks[TYPEAIR].Tile    := [288,173];
    OB_Obelisks[TYPEWATER].Tile  := [311,148];
    OB_Obelisks[TYPEEARTH].Tile  := [311,127];
    OB_Obelisks[TYPEFIRE].Tile   := [289,104];

    OB_Obelisks[TYPEMIND].Tile   := [268,171];
    OB_Obelisks[TYPEBODY].Tile   := [251,164];
    OB_Obelisks[TYPECOSMIC].Tile := [304,163];
    OB_Obelisks[TYPECHAOS].Tile  := [244,148];
    OB_Obelisks[TYPENATURE].Tile := [302,111];
    OB_Obelisks[TYPELAW].Tile    := [254,111];
    OB_Obelisks[TYPEDEATH].Tile  := [246,128];
    OB_Obelisks[TYPEBLOOD].Tile  := [271,104];

    for i:=0 to High(OB_Obelisks) do
    begin
      OB_Obelisks[i].Name     := 'Obelisk ('+RuneNames[i]+')';
      OB_Obelisks[i].WalkTile := OB_Obelisks[i].Tile;
      OB_Obelisks[i].Colors   := [CTS2(8494476, 13, 1.69, 0.66)];
      OB_Obelisks[i].UpText   := ['Enter','Guardian of'];
      OB_Obelisks[i].Expand   := 7;
    end;

    Tiles := [[292,158], [306,143], [305,128], [291,113], [268,163], [259,157], [298,151], [255,147], [296,119], [261,116], [255,126], [270,113]];
    for i:=TYPEAIR to TYPEBLOOD do
      OB_Obelisks[i].WalkTile := Tiles[i];

  { Elemental altars }
    with OB_Altars[TYPEAIR] do
    begin
      Name      := 'Altar (air)';
      Colors    := [CTS2(6383470, 11, 0.33, 0.35)];
      ExitCol   := CTS2(8826550, 8, 0.22, 0.68);
      UpText    := ['Craft-rune','-rune Altar'];
      Expand    := 3;
      Tile      := [1402,654];
      WalkTile  := [1398,660];
      ExitTiles := [[1389,675]];
    end;
    with OB_Altars[TYPEWATER] do
    begin
      Name      := 'Altar (water)';
      Colors    := [CTS2(6383470, 11, 0.33, 0.35)];
      ExitCol   := CTS2(13615806, 14, 0.20, 0.51);
      UpText    := ['Craft-rune','-rune'];
      Expand    := 7;
      Tile      := [888,643]; //[888,642];
      MidTile   := [909,652];
      WalkTile  := [897,647];
      ExitTiles := [[934,660]];
    end;
    with OB_Altars[TYPEEARTH] do
    begin
      Name      := 'Altar (earth)';
      Colors    := [CTS2(6383470, 11, 0.33, 0.35)];
      ExitCol   := CTS2(7645105, 13, 0.09, 0.67);
      UpText    := ['Craft-rune','-rune'];
      Expand    := 5;
      Tile      := [658,624];
      MidTile   := [651,642];
      WalkTile  := [658,630];
      ExitTiles := [[646,670]];
    end;
    with OB_Altars[TYPEFIRE] do
    begin
      Name      := 'Altar (fire)';
      Colors    := [CTS2(6383470, 11, 0.33, 0.35)];
      ExitCol   := CTS2(3365036, 4, 0.57, 2.67);
      UpText    := ['Craft-rune','-rune'];
      Expand    := 5;
      Tile      := [365,634]; //[363,631];
      MidTile   := [344,614];
      WalkTile  := [357,631];
      ExitTiles := [[323,587]];
    end;
  { Catalytic altars }
    with OB_Altars[TYPEMIND] do
    begin
      Name      := 'Altar (mind)';
      Colors    := [CTS2(6383470, 11, 0.33, 0.35)];
      ExitCol   := CTS2(9741996, 6, 0.25, 0.86);
      UpText    := ['Craft-rune','-rune Altar'];
      Expand    := 3;
      Tile      := [1169,627];
      WalkTile  := [1174,631];
      ExitTiles := [[1198,678]];
    end;
    with OB_Altars[TYPEBODY] do
    begin
      Name      := 'Altar (body)';
      Colors    := [CTS2(6383470, 11, 0.33, 0.35)];
      ExitCol   := CTS2(9736653, 4, 0.08, 1.82);
      UpText    := ['Craft-rune','-rune Altar'];
      Expand    := 3;
      Tile      := [118,627];
      WalkTile  := [114,636];
      ExitTiles := [[110,656]];
    end;
    with OB_Altars[TYPECOSMIC] do
    begin
      Name      := 'Altar (cosmic)';
      Colors    := [CTS2(6383470, 11, 0.33, 0.35)];
      ExitCol   := CTS2(9415855, 11, 0.11, 0.75);
      UpText    := ['Craft-rune','-rune Altar'];
      Expand    := 3;
      Tile      := [663,131];
      WalkTile  := [663,131];
      ExitTiles := [[663,50], [746,135], [663,216], [582,133]];
    end;
    with OB_Altars[TYPECHAOS] do
    begin
      Name      := 'Altar (chaos)';
      Colors    := [CTS2(6383470, 11, 0.33, 0.35)];
      ExitCol   := CTS2(9029068, 19, 0.07, 1.28);
      UpText    := ['Craft-rune','-rune Altar'];
      Expand    := 3;
      Tile      := [1179,100];
      WalkTile  := [1188,101];
      ExitTiles := [[1221,118]];
    end;
    with OB_Altars[TYPENATURE] do
    begin
      Name      := 'Altar (nature)';
      Colors    := [CTS2(6383470, 11, 0.33, 0.35)];
      ExitCol   := CTS2(9616323, 7, 0.20, 0.90);
      UpText    := ['Craft-rune','-rune Altar'];
      Expand    := 3;
      Tile      := [926,357];
      WalkTile  := [926,363];
      ExitTiles := [[926,383]];
    end;
    with OB_Altars[TYPELAW] do
    begin
      Name      := 'Altar (law)';
      Colors    := [CTS2(6383470, 11, 0.33, 0.35)];
      ExitCol   := CTS2(9677721, 11, 0.94, 0.85);
      UpText    := ['Craft-rune','-rune Altar'];
      Expand    := 3;
      Tile      := [1181,391];
      MidTile   := [1183,417];
      WalkTile  := [1181,397];
      ExitTiles := [[1183,451]];
    end;
    with OB_Altars[TYPEDEATH] do
    begin
      Name      := 'Altar (death)';
      Colors    := [CTS2(6383470, 11, 0.33, 0.35)];
      ExitCol   := CTS2(8363682, 16, 0.14, 0.62);
      UpText    := ['Craft-rune','-rune Altar'];
      Expand    := 3;
      Tile      := [916,123];
      WalkTile  := [920,129];
      ExitTiles := [[928,148]]; // TORWENT EDIT
    end;
    with OB_Altars[TYPEBLOOD] do
    begin
      Name      := 'Altar (blood)';
      Colors    := [CTS2(4409210, 7, 0.13, 3.43)];
      ExitCol   := CTS2(2637186, 13, 0.20, 1.46);
      UpText    := ['Craft-rune','-rune Altar'];
      Expand    := 3;
      Tile      := [1440,217];    // TORWENT EDIT
      WalkTile  := [1448,217];    // TORWENT EDIT
      ExitTiles := [[1408,217], [1472, 217]];  // TORWENT EDIT
    end;
  end;
  Bot.ShutdownTime  := GetTimeRunning + maxTime;
  Self.TrueRunTime.Start();
end;

procedure TScript.ChainerRun(maxTime: UInt64);
begin
  writeln('STARTING AEROGUARDIANS CHAINER RUN');
  bot.Init(maxTime);
  Self.Run();

  Self.rsw.Setup('world', [RSRegions.CASTLE_WARS, RSREGIONS.GUARDIANS_OF_THE_RIFT]);
  wait(500, 800);

  while not RSRegions.CASTLE_WARS.Contains(Self.RSW.getmypos()) do
  begin
    TeleportToCastleWars;
    if not WaitUntil(RSRegions.CASTLE_WARS.Contains(Self.RSW.getmypos()),300, 3000) then
    begin
      writeln('Failed teleporting to Castle Wars, retrying');
    end else
    begin
    writeln('Teleported to castle wars');
    end;
  end;

  while (Inventory.Count >= 1) do
  begin
    wait(1000, 3000);
    Self.RSW.webwalk([5166, 4115]);
    if Bank.open() then
    begin
      Bank.DepositAll();
      wait(200, 300);
      Mouse.click([467, 299, 493, 325], 1);
    end;

    Bank.Close();
  end;
  Antiban.Tasks := [];
  Antiban.Breaks := [];
  writeln('AEROGUARDIANS CHAINER RUN DONE ----------');
end;

{$IFNDEF SCRIPT_CHAIN}
begin
  Bot.ChainerRun(2030203);
end.
{$ENDIF}
