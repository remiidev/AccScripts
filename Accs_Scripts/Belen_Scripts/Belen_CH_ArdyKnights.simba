{$IFNDEF SCRIPT_CHAIN}
  {$DEFINE SRL_USE_REMOTEINPUT}
  {$I SRL-T/osr.simba}
  {$I WaspLib/osr.simba}
{$ENDIF}
{$include_once ../Scripts/Accs_Scripts/RemiLib.simba}

var
  BANK_POLYGON: TPointArray = [[5960, 3265], [6052, 3265], [6052, 3350], [5960, 3350]] ;

//Enum of script states. used in the GetState() function to decide what we got to do next.
type
  EThieverState = (
    OPEN_CHAT,
    CHANGE_CHAT_OFF,
    CHANGE_CHAT_FILTER,
    IS_UPSTAIRS,
    WALK_TO_BANK,

    OPEN_BANK,
    OPEN_COLLECT,
    DEPOSIT_ITEMS,
    WITHDRAW_NECK,
    DEPOSIT_NECK,
    WITHDRAW_FOOD,
    FIX_INVENTORY,
    HANDLE_COLLECT,
    CLOSE_INTERFACE,
    CAST_SHADOW_VEIL,

    EQUIP_ROGUE,
    CHECK_NECK,
    EQUIP_NECK,
    EAT_FOOD,

    FIND_KNIGHT,
    PICKPOCKET,
    OPEN_POUCH,

    CLOSE_CONTEXT,

    WAIT_STATE,

    OUT_OF_SUPPLIES,
    END_SCRIPT
  );

//script record, all variables of the script should go here.
  TKnightsThiever = record
    //init variables (to be set while the script is initiates)
    State: EThieverState;

    Knight: TRSNPC;

    CoinPouch: TRSItem;
    Necklace: TRSBankItem;

    LootArray: TRSItemArray;
    KeepArray: TRSItemArray;
    BankArray: TRSItemArray;
    RogueEquipment: TRSItemArray;

    NeckTimer, ShadowVeilTimer: TCountDown;

    DiaryLevel: Int32;
    FoodAmount: Int32;
    NeckAmount: Int32;
    MinHealth: Int32;
    Food: TRSBankItem;

    //run variables (to be used while the script is running)
    HasNeck, UseShadowVeil: Boolean;
    FreshNeck: Boolean;
    Actions: Int32;
    ShutdownTime: Int32;

    CoinPouchLimit, VeilAttempts: Int32;
    MaxHit: Int32;
    NextHeal: Int32;
    Pattern: Int32;
    TakeBreaks,TakeSleeps: Boolean;

    RSW: TRSWalker;
  end;


//Extra antiban specifically for this script.

procedure TKnightsThiever.SetupAntiban();
begin
  Antiban.Skills := [ERSSkill.THIEVING];
  Antiban.MinZoom := 20;
  Antiban.MaxZoom := 60;


  Antiban.AddTask(ONE_SECOND*45, @Mouse.RandomMovement);
  Antiban.AddTask(ONE_MINUTE*8,  @Antiban.RandomRotate);
  Antiban.AddTask(ONE_MINUTE*23,  @Antiban.Swivel);
  Antiban.AddTask(ONE_MINUTE*12,  @Antiban.HoverMSPlayers);
  Antiban.AddTask(ONE_MINUTE*7,  @Antiban.DoMidLoseFocus);
  Antiban.AddTask(ONE_MINUTE*25, @Antiban.HoverSkills);
  Antiban.AddTask(ONE_MINUTE*12, @Antiban.AdjustZoom);

  Antiban.AddBreak(ONE_MINUTE*30, ONE_SECOND*90, 0.4, 0.0);
  Antiban.AddBreak(ONE_MINUTE*50, ONE_MINUTE*4, 0.4, 0.0);
  Antiban.AddBreak(ONE_MINUTE*30, ONE_MINUTE*2, 0.4, 0.0);

end;
procedure TKnightsThiever.CheckRogueEquipment();
var
  ProfitMultiplier: Double;
begin
  if Inventory.Open() then
  begin
    if Inventory.ContainsItem('Rogue mask') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue mask';
    end;

    if Inventory.ContainsItem('Rogue top') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue top';
    end;

    if Inventory.ContainsItem('Rogue trousers') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue trousers';
    end;

    if Inventory.ContainsItem('Rogue gloves') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue gloves';
    end;

    if Inventory.ContainsItem('Rogue boots') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue boots';
    end;

    //This are not part of rogue equipment but are useful while thieving
    if Inventory.ContainsItem('Thieving cape') then
      Self.RogueEquipment += 'Thieving cape'
    else if Inventory.ContainsItem('Thieving cape(t)') then
      Self.RogueEquipment += 'Thieving cape(t)';

    //Lava staves for shadow veil spell
    if Inventory.ContainsItem('Lava battlestaff') then
      Self.RogueEquipment += 'Lava battlestaff'
    else if Inventory.ContainsItem('Mystic lava staff') then
      Self.RogueEquipment += 'Mystic lava staff'
    else if Inventory.ContainsItem(21200) then
      Self.RogueEquipment += 21200;
  end;

  if Equipment.Open() then
  begin
    if Equipment.ContainsItem('Rogue mask') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue mask';
    end;

    if Equipment.ContainsItem('Rogue top') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue top';
    end;

    if Equipment.ContainsItem('Rogue trousers') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue trousers';
    end;

    if Equipment.ContainsItem('Rogue gloves') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue gloves';
    end;

    if Equipment.ContainsItem('Rogue boots') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue boots';
    end;


    //This are not part of rogue equipment but are useful while thieving
    if Equipment.ContainsItem('Thieving cape') then
      Self.RogueEquipment += 'Thieving cape'
    else if Equipment.ContainsItem('Thieving cape(t)') then
      Self.RogueEquipment += 'Thieving cape(t)';

    //Lava staves for shadow veil spell
    if Equipment.ContainsItem('Lava battlestaff') then
      Self.RogueEquipment += 'Lava battlestaff'
    else if Equipment.ContainsItem('Mystic lava staff') then
      Self.RogueEquipment += 'Mystic lava staff'
    else if Equipment.ContainsItem(21200) then
      Self.RogueEquipment += 21200;
  end;
end;

procedure TKnightsThiever.SetupKnight();
var
  p: TPoint;
begin
  p := [6013, 3300];
  Self.Knight.SetupCoordinates([p]);
  Self.Knight.DotFilter.Setup(BANK_POLYGON, True);
  Self.Knight.ShapeArray.SetShape([1, 1, 6]);
  Self.Knight.Setup(['Knight', 'of', 'Ardougne']);
  Self.Knight.Finder.Colors += CTS2(10620793, 19, 0.22, 0.31);
end;


function TKnightsThiever.HasRogue(): Boolean;
begin
  Result := Inventory.ContainsAny(Self.RogueEquipment);
end;

function TKnightsThiever.EquipRogue(): Boolean;
var
  Item: TRSItem;
begin
  for Item in Self.RogueEquipment do
    if Inventory.ClickItem(Item) then
      Wait(200, 300);

  if Inventory.ClickItem(21200) then
    Wait(200, 300);

  Result := not Self.HasRogue() and not Inventory.ContainsItem('Lava battlestaff');
end;



function TKnightsThiever.HasSpace(): Boolean;
begin            //we need at least 2 spaces always.
  Result := (Inventory.CountEmptySlots() >= 2) or
            (Inventory.ContainsItem(Self.CoinPouch) and Inventory.ContainsItem('Coins')
             and not Inventory.ContainsAny(Self.BankArray));
end;

function TKnightsThiever.CastShadowVeil(): Boolean;
begin
  if not Magic.Open() then
    Exit;

  if not Magic.CanActivate(ERSSpell.SHADOW_VEIL) then
  begin
    if Self.VeilAttempts > 2 then
    begin
      writeln('Disabling shadow veil.');
      Self.UseShadowVeil := Result;
      Exit;
    end;

    writeln('Shadow veil is not available yet.');
    Self.ShadowVeilTimer.Restart(Random(-5000, 5000));
    Self.VeilAttempts += 1;
    Exit;
  end;

  Result := Magic.CastSpell(ERSSpell.SHADOW_VEIL);
  Self.ShadowVeilTimer.Restart(Random(-5000, 5000));
  Self.VeilAttempts := 0;
end;


function TKnightsThiever.IsLowHP(): Boolean;
begin
  if Self.NextHeal < 1 then
  begin
    Self.NextHeal := MinHealth + Random(-Self.MaxHit, Self.MaxHit) * Antiban.GetUniqueInt(2, 0, 4);
    Self.NextHeal := EnsureRange(Self.NextHeal, Self.MaxHit, Round(Stats.GetLevel(ERSSkill.HITPOINTS) * 0.8));
  end;

  Result := Minimap.GetHPLevel() <= Self.NextHeal;
end;

function TKnightsThiever.IsPouchFull(): Boolean;
begin
  if Self.CoinPouchLimit < 1 then
    Self.CoinPouchLimit := SRL.TruncatedGauss(28 * DiaryLevel, 1);

  Result := Inventory.CountItemStack(Self.CoinPouch) >= Self.CoinPouchLimit;
end;


function TKnightsThiever.OpenCoinPouch(): Boolean;
var
  pouchCount: Int32;
begin
  pouchCount := Inventory.CountItemStack(Self.CoinPouch);
  if Inventory.ClickItem(Self.CoinPouch) then
  begin
    Wait(600);
    Result := WaitUntil(not Inventory.ContainsItem(Self.CoinPouch), 100, 2000);
  end;

  if Result then
  begin
    Self.CoinPouchLimit := SRL.TruncatedGauss(28 * DiaryLevel, 1);
    Self.Actions += pouchCount;
  end;
end;


function TKnightsThiever.CheckFailed(StartingHP: Int32): Boolean;
var
  HasHitSplat: Boolean;
begin
  HasHitSplat := MainScreen.FindHitsplats(MainScreen.GetPlayerBox()) <> [];

  Result := (Minimap.GetHPLevel() < StartingHP) or HasHitSplat;

  if Result then
  begin
    XPBar.EarnedXP();
    Self.OpenCoinPouch();
  end;
end;

function TKnightsThiever.NecklaceExpired(): Boolean;
begin
  Result := Chat.FindMessage('crumbles', [CHAT_COLOR_LIGHT_RED]);
  Self.HasNeck := not Result;
end;

function TKnightsThiever.Dodged(): Boolean;
begin
  Result := Chat.FindMessage('dodgy');
end;



function TKnightsThiever.Heal(): Boolean;
var
  oldHP, newHP, hpLevel: Int32;
begin
  newHP := Minimap.GetHPLevel();
  hpLevel := Stats.GetLevel(ERSSkill.HITPOINTS) - 1;
  repeat
    oldHP := newHP;
    if not Inventory.ClickItem(Self.Food.Item) then
      Exit;

    newHP := Minimap.GetHPLevel();
    Result := newHP > Random(oldHP, hpLevel);
  until Result;

  if Result then
    Self.NextHeal := 0; //This will be reset when TKnightsThiever.IsLowHP() is called.
end;

function TKnightsThiever.EquipNeck(): Boolean;
var
  slot: Int32;
begin
  Result := Inventory.FindItem(Self.Necklace.Item, slot);

  if Result then
  begin
    Inventory.ClickSlot(slot);
    WaitUntil(not Inventory.IsSlotUsed(slot), 300, 3000);
    Self.FreshNeck := True;
    Self.HasNeck := True;
  end;
end;

function TKnightsThiever.CheckNeck(): Boolean;
begin
  Result := Self.HasNeck := Equipment.ContainsItem(Self.Necklace.Item);

  Self.NeckTimer.Restart(Random(-30000, 60000));
end;


function TKnightsThiever.HoverKnight(): Boolean;
var
  t: TCountDown;
  TPA: TPointArray;
  ATPA: T2DPointArray;
  P: TPoint;
  B: TBox;
begin
  t.Init(1800);

  repeat
    SRL.FindColors(TPA, $00FFFF, MainScreen.Bounds());
    ATPA := TPA.Cluster(3, 1);
    ATPA.FilterDimensions(32, 10, 32, 10);
  until (ATPA <> []) or t.IsFinished();

  if ATPA <> [] then
  begin
    ATPA.SortByMiddle(MainScreen.GetPlayerBox().Middle());
    TPA := ATPA[0];
    P := TPA.Mean();
    P.X += MainScreen.NormalizeDistance(7);
    P.Y += MainScreen.NormalizeDistance(22);
    B := Box(P, MainScreen.NormalizeDistance(10), MainScreen.NormalizeDistance(14));

    if WLSettings.RemoteInput.HUDDebug then
    begin
      RSClient.Image().Clear();
      RSClient.Image().DrawBox(B, $FFFFFF);
    end;

    Mouse.Move(B);
    Result := MainScreen.IsUpText(Self.Knight.UpText);
  end
  else if Length(Minimap.GetDots(ERSMinimapDot.PLAYER)) < 10 then
    Result := Self.Knight.Hover(0);

  if not Result and MainScreen.IsUpText('Climb') then
    Antiban.RandomRotate();
end;

function TKnightsThiever.StealKnight(): Boolean;
var
  slot: Int32 := Inventory.GetSelectedSlot();
  currentHP: Int32 := Minimap.GetHPLevel();
  circle: TCircle;
  i: Int32;
begin
  if Slot > -1 then Inventory.ClickSlot(Slot);

  if Result := Self.HoverKnight() then
  begin
    case Self.Pattern of
      2, 3, 4: Wait(200, 300);
      5, 6: Wait(600, 800);
    end;

    Self.Pattern :=  SRL.TruncatedGauss(0, 6);

    Mouse.Click(MOUSE_LEFT);

    if MainScreen.DidYellowClick() then
      Exit(False);

    Wait(50, 100);

    case Self.Pattern of
      4:
      for i := 1 to  SRL.TruncatedGauss(0, 2) do
      begin
        circle.X := Mouse.Position().X;
        circle.Y := Mouse.Position().Y;
        circle.Radius := 5;

        Mouse.Click(circle, MOUSE_LEFT, True);
        Wait(200, 350);
      end;
      6:
      for i := 1 to  SRL.TruncatedGauss(0, 3) do
      begin
        circle.X := Mouse.Position().X;
        circle.Y := Mouse.Position().Y;
        circle.Radius := 5;

        Mouse.Click(circle, MOUSE_LEFT, True);
        Wait(10, 50);
      end;
    end;

    if not Self.NecklaceExpired() then
      Self.FreshNeck := False;

    Self.CheckFailed(CurrentHP);
    WL.Activity.Restart();
  end;
end;


function TKnightsThiever.Deposit(): Boolean;
begin
  Result := Bank.DepositItems(Self.BankArray, False);
end;

function TKnightsThiever.FixInventory(): Boolean;
begin
  if (Inventory.CountItem(Self.Necklace.Item) < (NeckAmount-2)) or
     not Inventory.HasEnoughConsumable(ERSConsumable.FOOD) then
  begin
    Bank.CachedQuantity := 0;
    Bank.DepositAll();
  end;

  Self.Necklace.Quantity := 1;
  Result := Bank.DepositItem(Self.Necklace, False);
end;

function TKnightsThiever.Withdraw(out item: TRSBankItem; attempts: Int32 = 3): Boolean;
begin
  if item = Self.Necklace then
    item.Quantity := NeckAmount - Inventory.CountItem(Self.Necklace.Item);

  Result := Bank.WithdrawItem(item, True);
end;

procedure TKnightsThiever.HandleUpstairs();
const
  Finder: TRSObjectFinder = [[[5395288, 3, 0.95, 0.22]], [], 0, 0, 0, 0, 0, 0, 0];
var
  TPA: TPointArray;
begin
  repeat
    for TPA in MainScreen.FindObject(Finder, MainScreen.GetPlayerBox.Expand(10)) do
    begin
      Mouse.Move(TPA);
      if MainScreen.IsUpText('down') then
      begin
        Mouse.Click(MOUSE_LEFT);
        if MainScreen.DidRedClick() then
        begin
          WaitUntil(Minimap.OnGroundLevel(), 100, 5000);
          Wait(2000);
        end;
      end;
    end;
  until Minimap.OnGroundLevel();
end;


function TKnightsThiever.GetState(): EThieverState;
begin
  if ChooseOption.IsOpen() then
    Exit(EThieverState.CLOSE_CONTEXT);

  if MainScreen.HasInterface() then
  begin
    if Bank.IsOpen() then
    begin
      if Inventory.ContainsAny(Self.BankArray) then
        Exit(EThieverState.DEPOSIT_ITEMS);

      if Inventory.IsFull() then
        Exit(EThieverState.FIX_INVENTORY);

      case Inventory.CountItem(Self.Necklace.Item) of
        0..(NeckAmount-2): Exit(EThieverState.WITHDRAW_NECK);
        (NeckAmount-2)..(NeckAmount+2): ;
        else Exit(EThieverState.DEPOSIT_NECK);
      end;

      if not Inventory.ContainsItem(Food.Item) then
        Exit(EThieverState.WITHDRAW_FOOD);
    end;

    Exit(EThieverState.CLOSE_INTERFACE);
  end;

  if Self.IsPouchFull() then
    Exit(EThieverState.OPEN_POUCH);

  if ChatButtons.GetState(ERSChatButton.PUBLIC_CHAT) <> ERSChatButtonState.DISABLED then
    Exit(EThieverState.CHANGE_CHAT_OFF);

  if ChatButtons.GetState(ERSChatButton.GAME_CHAT) <> ERSChatButtonState.ENABLED then
    Exit(EThieverState.CHANGE_CHAT_FILTER);

  if not ChatButtons.IsActive(ERSChatButton.GAME_CHAT) then
    Exit(EThieverState.OPEN_CHAT);

  if Self.NeckTimer.IsFinished() then
    Exit(EThieverState.CHECK_NECK);

  if Self.HasRogue() then
    Exit(EThieverState.EQUIP_ROGUE);

  if not Self.HasSpace() then
  begin
    if Inventory.ContainsAny(Self.BankArray) then
      Exit(EThieverState.OPEN_BANK);
    if Inventory.FindConsumable(ERSConsumable.FOOD) then
      Exit(EThieverState.EAT_FOOD);

    Exit(EThieverState.OPEN_BANK);
  end;

  if Self.UseShadowVeil and Self.ShadowVeilTimer.IsFinished() then
    Exit(EThieverState.CAST_SHADOW_VEIL);

  if (NeckAmount > 0) and not Self.FreshNeck and (not Self.HasNeck or Self.NecklaceExpired) then
  begin
    if Inventory.ContainsItem(Self.Necklace.Item) then
      Exit(EThieverState.EQUIP_NECK);

    Exit(EThieverState.OPEN_BANK);
  end;

  if Self.IsLowHP() then
  begin
    if Inventory.FindConsumable(ERSConsumable.FOOD) then
      Exit(EThieverState.EAT_FOOD);

    Exit(EThieverState.OPEN_BANK);
  end;

  if not Minimap.OnGroundLevel() then
    Exit(EThieverState.IS_UPSTAIRS);

  if not Self.RSW.InPoly(BANK_POLYGON) then
    Exit(EThieverState.WALK_TO_BANK);

  Exit(EThieverState.PICKPOCKET);
end;

procedure TKnightsThiever.Run();
var
 prevState: EThieverState;
begin
  repeat
    Self.State := Self.GetState();
    if State <> prevState then
      Writeln('Doing: ', State);
    prevState := State;

    case Self.State of
      EThieverState.OPEN_BANK: Bank.WalkOpen();
      EThieverState.DEPOSIT_ITEMS: Self.Deposit();
      EThieverState.WITHDRAW_FOOD:
      begin
        Bank.WithdrawItem(Food, False);
        WaitUntil(Inventory.ContainsItem(Self.Food.Item),300, 3000);
      end;
      EThieverState.WITHDRAW_NECK:
      begin
        Bank.WithdrawItem(Self.Necklace, False);
        WaitUntil(Inventory.ContainsItem(Self.Necklace.Item),400, 3000);
      end;
      EThieverState.DEPOSIT_NECK: Bank.DepositItem(Self.Necklace, False);
      EThieverState.FIX_INVENTORY: Self.FixInventory();
      EThieverState.CLOSE_INTERFACE: MainScreen.CloseInterface();

      EThieverState.OPEN_CHAT: ChatButtons.Open(ERSChatButton.GAME_CHAT);
      EThieverState.CHANGE_CHAT_OFF: ChatButtons.ChangeState(ERSChatButton.PUBLIC_CHAT, ERSChatButtonState.DISABLED);
      EThieverState.CHANGE_CHAT_FILTER: ChatButtons.ChangeState(ERSChatButton.GAME_CHAT, ERSChatButtonState.ENABLED);

      EThieverState.PICKPOCKET: Self.StealKnight();
      EThieverState.OPEN_POUCH: Self.OpenCoinPouch();

      EThieverState.EAT_FOOD: Self.Heal();
      EThieverState.EQUIP_NECK: Self.EquipNeck();
      EThieverState.CHECK_NECK: Self.CheckNeck();
      EThieverState.CLOSE_CONTEXT: ChooseOption.Close();
      EThieverState.IS_UPSTAIRS: Self.HandleUpstairs();
      EThieverState.WALK_TO_BANK: Self.RSW.WebWalk(Self.Knight.Coordinates, 30, 0.2);
      EThieverState.EQUIP_ROGUE: Self.EquipRogue();
      EThieverState.CAST_SHADOW_VEIL: Self.CastShadowVeil();

      EThieverState.OUT_OF_SUPPLIES, EThieverState.END_SCRIPT: Break;
    end;

    Antiban.DoAntiban();       //Checks for due antiban
  until(GetTimeRunning > Self.ShutdownTime);  //Stops if MaxAtions or MaxTime have been reached.
end;

var
  KnightsThiever: TKnightsThiever;

procedure TKnightsThiever.Init(maxTime: UInt64);
var
  mypos_ : Tpoint;
  Inventory_ : TRSBankItemArray;
  inventoryitems: TRSItemArray;
  i, j, World: Int32;
  inSplashingWorld : Boolean;
  a : TPointArray;
  TPA : TPointArray;
  WorldList : TIntegerArray;
  T: TCountDown;

begin
  Mouse.Speed      := 14 + Antiban.GetBehavior(EBioBehavior.MOUSE_SPEED);
  Mouse.Gravity    := 8  + Round(Antiban.GetBehavior(EBioBehavior.MOUSE_GRAVITY) / 2);
  Mouse.Wind       := 3  + Round(Antiban.GetBehavior(EBioBehavior.MOUSE_WIND) / 2);
  Mouse.MissChance := 11 + Antiban.GetBehavior(EBioBehavior.MOUSE_MISS);
  Mouse.CanIdle    := True;

  Self.SetupAntiban();

  if (not RSClient.IsLoggedIn) then
    Login.LoginPlayer();

  if (not InRange(Options.GetZoomLevel, 20, 30)) then
    Options.SetZoomLevel(SRL.TruncatedGauss(20,30));
  MM2MS.ZoomLevel := Options.GetZoomLevel();

  DiaryLevel:= 1;
  FoodAmount:= 15;
  NeckAmount:= 5;
  MinHealth:= Random(20, 40);
  WorldList:= RSWorldLists.THIEVING_ARDY;

  Self.Food:= ['Jug of wine', Self.FoodAmount, False, 0, -1];
  Self.Necklace := ['Dodgy necklace', Self.NeckAmount, False, 0, -1];

  if DiaryLevel = 4 then
    DiaryLevel += 1;

  Self.RSW.SetupRegions([RSRegions.CASTLE_WARS, RSRegions.ARDOUGNE]);
  Self.SetupKnight();

//INVENTORY
  //SETUP BANK/INVENTORY + ADD REGIONS
  repeat
  begin
    if Bank.Open(ERSBankLocation.CASTLE_WARS) then
    begin
      Inventory_ += TRSBankItem.Setup('Dodgy necklace', 5, False);
      Inventory_[0].Tab := 2; Inventory_[0].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Jug of wine', 15, False);
      Inventory_[1].Tab := 0; Inventory_[1].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Lava battlestaff', 1, False);
      Inventory_[2].Tab := 2; Inventory_[2].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Rune pouch', 1, False);
      Inventory_[3].Tab := 0; Inventory_[3].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Ardougne teleport', 1, False);
      Inventory_[4].Tab := 1; Inventory_[4].Scroll := 0;
      Inventory_ += TRSBankItem.Setup('Ring of dueling(1)', 1, False);
      Inventory_[5].Tab := 1; Inventory_[5].Scroll := 0;

      inventoryitems += 'Jug of wine';
      inventoryitems += 'Dodgy necklace';
      inventoryitems += 'Rune pouch';
      inventoryitems += 'Ardougne teleport';

      for i := 0 to High(Inventory_) do
      begin
        Bank.WithdrawItem(Inventory_[i], True);
        Wait(0, 72);
      end;
    end else
    begin
      Self.RSW.webwalk([5166, 4115]);
    end;
  end;
  Until Inventory.count >= 1;

  while Bank.IsOpen() do
    Bank.Close();

  while not Inventory.IsOpen() do
    Inventory.Open();

  for i := 0 to High(Inventory_) do
  begin
    if not inventoryitems.Contains(Inventory_[i].Item) then
    begin
      Inventory.ClickItem(Inventory_[i].Item);
      Wait(0, 72);
    end;
  end;
  wait(200, 560);

//TRAVEL
  wait(400, 800);

  if Inventory.ClickItem('Ardougne teleport', 'Break') then
  begin
    waitUntil(isPlayerIn(Self.rsw.GetMyPos, RSRegions.ARDOUGNE), 400, 10000);
    writeln('Teleported');
  end;

  for 1 to 5 do
  begin
    if Self.rsw.WebWalk([6006, 3313], 2) then
    begin
      writeln('Walked to the bank');
      wait(1000, 2200);
      Break;
    end else
    begin
      writeln('Walker failed, retrying');
    end;
  end;

  while not inSplashingWorld do
  begin
    if WorldList = [] then
      WorldList := RSWorldLists.GENERAL;

    for World in WorldList do
    begin

      if inSplashingWorld then
        Break;

      j := logout.GetWorld;
      writeln('LOOKING FOR HIT SPLASHES');
      T.Init(10000);
      while T.TimeRemaining do
      begin
       writeln(T.TimeRemaining);
       //BloodSplash Finder
       srl.FindColors(TPA, CTS2(65855, 5, 0.01, 0.70), MainScreen.Bounds);
       if tpa.len > 200 then begin
        writeln('Encontro sangre');
        inSplashingWorld := True;
        Break;
       end else
       begin
        writeln('NO encontro sangre');
       end;
      end;
      if not inSplashingWorld then
      begin
        writeln('No encontro sangre en 10 segundos, hopping');
        WorldList.Remove(World, True);
        writeln('REMII: Hopping to', World);
        if HopWorlds(World) then
          writeln('REMII: Hopped to', World);
        writeln('Esperando que cambie el numero');
        WaitUntil(Logout.GetWorld <> j, 500, 20000);
        writeln('Cambio el numero');
        wait(2000,3000);
      end;
    end;
  end;

  Self.CoinPouch := 'Coin pouch';
  Self.KeepArray := ['Coin pouch', 'Coins', 'Cosmic rune', 'Dodgy necklace', 'Rune pouch'];
  Self.BankArray := ['Jug', 'Pie dish'];

  Self.MaxHit := 3;
  MinHealth := Max(Self.MaxHit, MinHealth);

  Self.NeckTimer.Init(140000);

  if Antiban.BioDice() then
    Options.SetNPCAttackOption(ERSAttackOption.HIDDEN)
  else
    Options.SetNPCAttackOption(ERSAttackOption.ALWAYS_RIGHT_CLICK);
  Wait(800, 1200);
  Self.CheckRogueEquipment();
  Self.HasNeck := Equipment.ContainsItem(Self.Necklace.Item);


  if Magic.Open() and Magic.ContainsSpell(ERSSpell.SHADOW_VEIL) then
  begin
    Self.UseShadowVeil := True;
    Magic.CastSpell(ERSSpell.SHADOW_VEIL);
    Self.ShadowVeilTimer.Init(1100 * Round(0.6 * Stats.GetLevel(ERSSkill.MAGIC)));
  end;

  XPBar.EarnedXP();

  Self.ShutdownTime:= GetTimeRunning + maxTime;
end;

procedure TKnightsThiever.ChainerRun(maxTime: Uint32);
begin
  writeln('STARTING ARDY KNIGHT THIEV CHAINER RUN');
  Self.Init(maxTime);
  Self.Run();

  Inventory.ClickItem(Self.CoinPouch);

  while not RSRegions.CASTLE_WARS.Contains(Self.RSW.getmypos()) do
  begin
    TeleportToCastleWars;
    if not WaitUntil(RSRegions.CASTLE_WARS.Contains(Self.RSW.getmypos()),300, 3000) then
    begin
      writeln('Failed teleporting to Castle Wars, retrying');
    end else
    begin
    writeln('Teleported to castle wars');
    end;
  end;

  if Inventory.ContainsItem('Coin pouch') then
  begin
    Inventory.ClickItem('Coin pouch');
  end;

  while (Inventory.Count >= 1) do
  begin
    writeln('inv count:');
    writeln(Inventory.Count());
    WaitUntil(RSRegions.CASTLE_WARS.Contains(Self.RSW.getmypos()), 200, 2000);
    waitEx(250, 50);
    Bank.WalkOpen();
    if Bank.open() then
    begin
      Bank.DepositAll();
      wait(200, 300);
      Mouse.click([467, 299, 493, 325], 1);
    end;

    Bank.close();
  end;

  Self.RSW.Free();
  Antiban.Tasks := [];
  Antiban.Breaks := [];
  writeln('ARDY KNIGHT CHAINER RUN DONE ----------');
end;

{$IFNDEF SCRIPT_CHAIN}
begin
  KnightsThiever.ChainerRun(60000);
end.
{$ENDIF}
